#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children no
\language american
\language_package default
\inputencoding utf8
\fontencoding auto
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement class
\float_alignment class
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_formatted_ref 0
\use_minted 0
\use_lineno 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tablestyle default
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content true
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Title
Dive into Scala
\end_layout

\begin_layout Section*
PREFACE
\end_layout

\begin_layout Standard
Scala is a language that has a reputation for complexity and difficulty,
 but this attitude is entirely an artifact of a bygone era.
 It was the first to introduce many programming paradigms that have since been adopted into many other mainstream languages that are not cast in this light.
 The truth is scala is a harbinger of new ideas and idioms,
 and is one of the most academically scrutinized languages.
 This paper will lead the reader on a refreshed introduction,
 starting from minimal assumptions,
 and hopefully provide a jumping off point for whatever the reader wants to build.
\end_layout

\begin_layout Standard
A note should be made here regarding modern LLMs – they are a powerful tool that has made the act of creation *much* more streamlined,
 and indeed has removed many barriers to building software.
 As a result,
 the choice of language used should be less influenced by 
\begin_inset Quotes eld
\end_inset

what currently exists
\begin_inset Quotes erd
\end_inset

,
 and should leave the door wide open for devs to choose their own language to build in going forward.
 There has never been a better time to explore the choice of language,
 particularly for the backend.
 scala is definitely a 
\begin_inset Quotes eld
\end_inset

fine wine
\begin_inset Quotes erd
\end_inset

 of languages,
 and there has never been a better time to learn and implement with it.
\end_layout

\begin_layout Standard
Our approach will therefore be to first and foremost get you up and going.
 From there we will get a working example going & explore some basic scala.
\end_layout

\begin_layout Standard
Once we reach a level of comfort with this,
 we will give a brief overview of the basic structures and highlights of the language.
 Data types,
 control structures,
 regular expressions and the more broad 
\begin_inset Quotes eld
\end_inset

matching
\begin_inset Quotes erd
\end_inset

 paradigm that has been embraced by the language,
 blocks & iteration,
 i/o,
 and beyond.
\end_layout

\begin_layout Part
ELEMENTS OF SCALA
\end_layout

\begin_layout Section
FIRST STEPS
\end_layout

\begin_layout Subsection*
Installing Scala
\end_layout

\begin_layout Standard
Since the jvm and scala itself are so heavily researched and actively developed,
 scala is a moving target a little bit,
 as is the jvm,
 when it comes to install.
\end_layout

\begin_layout Standard
However,
 at the time of this writing,
 there are really only 2 things you need.
 Assuming you're ok with a localized install (eg.
 not across your OS),
 the steps are:
\end_layout

\begin_layout Itemize
create a folder for your project
\end_layout

\begin_layout Itemize
install JDK (temurin should be fine) to folder
\end_layout

\begin_deeper
\begin_layout Itemize
(https://adoptium.net/en-GB/temurin/releases at the time of this writing) to project dir
\end_layout

\end_deeper
\begin_layout Itemize
unzip scala cli (virtuslab is a nice one) to folder
\end_layout

\begin_deeper
\begin_layout Itemize
(https://github.com/VirtusLab/scala-cli/releases at the time of this writing) to project dir
\end_layout

\end_deeper
\begin_layout Itemize
add the following script to a batch file in the project root 
\series bold
/launch.bat
\series default
 file:
\end_layout

\begin_layout LyX-Code
@echo off
\end_layout

\begin_layout LyX-Code
::
 Set the path to your specific JVM folder
\end_layout

\begin_layout LyX-Code
set "JAVA_HOME=%~dp0jvm
\backslash
jdk-25.0.1+8"
\end_layout

\begin_layout LyX-Code
::
 Add our local bin and local java to the temporary PATH
\end_layout

\begin_layout LyX-Code
set "PATH=%~dp0bin;%JAVA_HOME%
\backslash
bin;%PATH%"
\end_layout

\begin_layout LyX-Code
echo ---------------------------------------
\end_layout

\begin_layout LyX-Code
echo Scala Portable Environment Loaded!
\end_layout

\begin_layout LyX-Code
echo ---------------------------------------
\end_layout

\begin_layout LyX-Code
echo Java Home:
 %JAVA_HOME%
\end_layout

\begin_layout LyX-Code
echo.
\end_layout

\begin_layout LyX-Code
::
 This creates or updates the config file every time you launch
\end_layout

\begin_layout LyX-Code
::
 Overwrite/Create project.scala with the first line (using a single >)
\end_layout

\begin_layout LyX-Code
(
\end_layout

\begin_layout LyX-Code
  echo // project.scala
\end_layout

\begin_layout LyX-Code
  echo //^> using javaOpt "--sun-misc-unsafe-memory-access=allow"
\end_layout

\begin_layout LyX-Code
  echo //^> using javaOpt "--add-opens=java.base/java.lang=ALL-UNNAMED"
\end_layout

\begin_layout LyX-Code
  echo //^> using dep com.lihaoyi::pprint:0.9.6
\end_layout

\begin_layout LyX-Code
) > project.scala
\end_layout

\begin_layout LyX-Code
::
 Verify Java is found
\end_layout

\begin_layout LyX-Code
java -version
\end_layout

\begin_layout LyX-Code
echo.
\end_layout

\begin_layout LyX-Code
::
 Verify Scala-CLI is found
\end_layout

\begin_layout LyX-Code
scala-cli --version
\end_layout

\begin_layout LyX-Code
echo ---------------------------------------
\end_layout

\begin_layout LyX-Code
cmd /k
\end_layout

\begin_layout Subsection*
Write & Run
\end_layout

\begin_layout Standard
Add some code:
\end_layout

\begin_layout Standard

\series bold
/hello.sc ->
\end_layout

\begin_layout LyX-Code
// Programmer moods
\end_layout

\begin_layout LyX-Code
enum Mood:
\end_layout

\begin_layout LyX-Code
  case Happy,
 Curious,
 Caffeinated
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
// Have empathy
\end_layout

\begin_layout LyX-Code
def response(mood:
 Mood) = mood match
\end_layout

\begin_layout LyX-Code
 case Mood.Happy       => "Keep coding!"
\end_layout

\begin_layout LyX-Code
  case Mood.Curious     => "Let's explore the source code."
\end_layout

\begin_layout LyX-Code
  case Mood.Caffeinated => "Compiling at the speed of light!"
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
// Typical morning
\end_layout

\begin_layout LyX-Code
val sequence = List(Mood.Happy,
 Mood.Caffeinated)
\end_layout

\begin_layout LyX-Code
sequence.map(response).foreach(println)
\end_layout

\begin_layout Standard
Open scala shell with our new batch file:
\end_layout

\begin_layout LyX-Code

\series bold
% launch.bat
\end_layout

\begin_layout Standard
Run the code:
\end_layout

\begin_layout LyX-Code

\series bold
% scala-cli .
\end_layout

\begin_layout LyX-Code
> Compiling project (Scala 3.7.4,
 JVM (25))
\end_layout

\begin_layout LyX-Code
> Compiled project (Scala 3.7.4,
 JVM (25))
\end_layout

\begin_layout LyX-Code
> 
\series bold
Keep coding!
\end_layout

\begin_layout LyX-Code
> 
\series bold
Compiling at the speed of light!
\end_layout

\begin_layout Section
new Scala()
\end_layout

\begin_layout Standard
The best way to learn a language that we've found is to build little mini-programs to showcase the fundamental features of a language,
 and then build out the complexity from there.
 Scala is a language that blends a couple of design orientations together to wonderful effect.
 
\end_layout

\begin_layout Subsection*
Scala is Object Oriented
\end_layout

\begin_layout Standard
Objects are a valued paradigm in scala.
 When figuring out how to solve a problem,
 we determine what classes of information we want to involve.
 In scala,
 we can define a class like so:
\end_layout

\begin_layout LyX-Code
// Define the class
\end_layout

\begin_layout LyX-Code
class Song(val title:
 String)
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
// Use it
\end_layout

\begin_layout LyX-Code
val favoriteSong = Song(
\begin_inset Quotes eld
\end_inset

Bad Moon Rising
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout LyX-Code
val anotherSong = Song(
\begin_inset Quotes eld
\end_inset

When it all Goes Wrong Again
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard
Classes are instantiated into instances.
 Classes can define parameters they take (such as title here),
 which also get assigned to public fields.
\end_layout

\begin_layout Standard
Alternatively,
 we can define and create single objects directly in a single statement:
\end_layout

\begin_layout LyX-Code
// Define a single object
\end_layout

\begin_layout LyX-Code
object Jukebox:
\end_layout

\begin_deeper
\begin_layout LyX-Code
val brand = 
\begin_inset Quotes eld
\end_inset

Vintage 1970
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code
def play(song:
 String):
 Unit =
\end_layout

\begin_layout LyX-Code
    println(s"The $brand Jukebox is now playing:
 $song")
\end_layout

\end_deeper
\begin_layout LyX-Code
// Call it
\end_layout

\begin_layout LyX-Code
Jukebox.play(
\begin_inset Quotes eld
\end_inset

My Song
\begin_inset Quotes erd
\end_inset

) // -> My Song
\end_layout

\begin_layout Standard
Note this is complete in and of itself.
 No instantiation.
 It can be used for things like settings.
\end_layout

\begin_layout Subsubsection*
Common Data Types
\end_layout

\begin_layout Standard
Some examples:
\end_layout

\begin_layout LyX-Code
\begin_inset Quotes eld
\end_inset

bubble boy
\begin_inset Quotes erd
\end_inset

.length
\end_layout

\begin_layout LyX-Code
\begin_inset Quotes eld
\end_inset

The Dude
\begin_inset Quotes erd
\end_inset

.indexOf('D')
\end_layout

\begin_layout LyX-Code
Jukebox.play(
\begin_inset Quotes eld
\end_inset

My Song
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout LyX-Code
-3981.abs
\end_layout

\begin_layout Subsubsection*
Traits
\end_layout

\begin_layout Standard
Traits are very similar to mixins in Ruby.
 They are partial classes that can be combined into other classes.
 Unlike inheritance (in languages like Java or C#),
 mixins don't require any sort of hierarchical relationship.
 They add a degree of power that conventional OO languages lack.
\end_layout

\begin_layout LyX-Code
trait Speakable:
\end_layout

\begin_layout LyX-Code
  def sayHi():
 Unit = println("Hi!")
\end_layout

\begin_layout LyX-Code
class Human extends Speakable
\end_layout

\begin_layout Subsection*
Scala is Functional
\end_layout

\begin_layout Standard
Chains of function calls are encouraged:
\end_layout

\begin_layout LyX-Code
val rawUsers = List("boop_ai",
 "sttp_dev",
 "scala_fan",
 "doobie_pro")
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
val result = rawUsers
\end_layout

\begin_layout LyX-Code
  .map(_.replace("_",
 " "))    // 1.
 Transform:
 Replace underscores
\end_layout

\begin_layout LyX-Code
  .map(_.capitalize)           // 2.
 Transform:
 Capitalize first letter
\end_layout

\begin_layout LyX-Code
  .filter(_.length > 8)        // 3.
 Filter:
 Only keep long names
\end_layout

\begin_layout LyX-Code
  .sorted                      // 4.
 Sort:
 Alphabetical order
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
println(s"Verified Users:
 $result")
\end_layout

\begin_layout Standard
A couple of quick things you will notice:
\end_layout

\begin_layout Standard
- 
\begin_inset Quotes eld
\end_inset

_
\begin_inset Quotes erd
\end_inset

 indicates each individual value of the list as we iterate through
\end_layout

\begin_layout Standard
- 
\begin_inset Quotes eld
\end_inset

.sorted
\begin_inset Quotes erd
\end_inset

 sorts the list based on it's data type
\end_layout

\begin_layout Standard
- s
\begin_inset Quotes erd
\end_inset

value
\begin_inset Quotes erd
\end_inset

 tells us we have variable values we will be substituting in,
 aka 
\begin_inset Quotes eld
\end_inset

interpolation
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Subsubsection*
Options
\end_layout

\begin_layout Standard
In scala,
 nulls are rarity.
 Wherever we have a value that may or may not be present,
 we use Option data types.
 The Option basically takes a class,
 and can be assigned values of that class.
 The key,
 however,
 is that it also distinguishes between *some* data and *no* data.
\end_layout

\begin_layout Standard
This is a key difference from more conventional languages.
 In a language like ruby or python (or even Java!),
 we often find ourselves writing logic gates by conditions as follows:
\end_layout

\begin_layout LyX-Code
if (data != null) {
\end_layout

\begin_layout LyX-Code
  // do something amazing,
 maybe with the data value itself
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
In these cases,
 before we ever use the value,
 we want to make sure it has something in it.
\end_layout

\begin_layout Standard
This pattern is kind of ugly and dangerous,
 since the 
\begin_inset Quotes eld
\end_inset

empty
\begin_inset Quotes erd
\end_inset

 state is 
\begin_inset Quotes eld
\end_inset

null
\begin_inset Quotes erd
\end_inset

 and therefore if we don't do the check but still use it,
 it can fail (sometimes in really bad ways).
\end_layout

\begin_layout Standard
So scala introduced an 
\begin_inset Quotes eld
\end_inset

Option
\begin_inset Quotes erd
\end_inset

 type:
\end_layout

\begin_layout LyX-Code
val user:
 Option[String] = Some("Albertus")
\end_layout

\begin_layout LyX-Code
val unknown:
 Option[String] = None
\end_layout

\begin_layout LyX-Code
println(user.getOrElse("Guest"))
\end_layout

\begin_layout Standard
Note that now,
 when the value is assigned,
 it *must* specify that it either has *Some* value or no value (None).
 There is no 
\begin_inset Quotes eld
\end_inset

null
\begin_inset Quotes erd
\end_inset

 state available.
\end_layout

\begin_layout Standard
Then,
 when the variable is used,
 we *must* state (implicitly) what we will do if the variable has no value (
\begin_inset Quotes eld
\end_inset

getOrElse
\begin_inset Quotes erd
\end_inset

).
 Every dereference of the value must also tell the software what to do if there is no value in the variable.
\end_layout

\begin_layout Standard
This can be a bit of a pain to get used to,
 but forces a degree of safety,
 thoroughness & clarity.
\end_layout

\begin_layout Subsection*
Scala is Both
\end_layout

\begin_layout Subsubsection*
Pattern Matching
\end_layout

\begin_layout Standard
match statements are a cornerstone of scala,
 taking the crown as the preferred method of control flow:
\end_layout

\begin_layout LyX-Code
val whiteSauceRecipe = 
\begin_inset Quotes eld
\end_inset

Mix butter,
 flour & water.
 Heat to reduce.
\begin_inset Quotes erd
\end_inset


\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
var recipe = whiteSauceRecipe
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
val result = recipe.indexOf(
\begin_inset Quotes eld
\end_inset

butter
\begin_inset Quotes erd
\end_inset

) match
\end_layout

\begin_layout LyX-Code
  case n if n >= 0 => 
\begin_inset Quotes eld
\end_inset

Have butter!
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout LyX-Code
  case _ => 
\begin_inset Quotes eld
\end_inset

Tastes bland
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
So in scala,
 we can 
\begin_inset Quotes eld
\end_inset

match
\begin_inset Quotes erd
\end_inset

 expressions and take actions based on different results (like a switch statement or multiple if statements but compressed).
\end_layout

\begin_layout Standard
So in this case,
 we 
\begin_inset Quotes eld
\end_inset

match
\begin_inset Quotes erd
\end_inset

 against the expression
\series bold
 recipe.indexOf(
\begin_inset Quotes eld
\end_inset

butter
\begin_inset Quotes erd
\end_inset

)
\series default
,
 with a 
\begin_inset Quotes eld
\end_inset

case
\begin_inset Quotes erd
\end_inset

 clause for each type of value we want to handle.
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

case _
\begin_inset Quotes erd
\end_inset

 is the 
\begin_inset Quotes eld
\end_inset

catch all
\begin_inset Quotes erd
\end_inset

 case where if we don't match against anything else,
 we return the given value (
\begin_inset Quotes eld
\end_inset

Tastes bland
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Standard
So in our case,
 because whiteSauceRecipe contains the substring 
\begin_inset Quotes eld
\end_inset

butter
\begin_inset Quotes erd
\end_inset

 (at index 4),
 we match against the first case ( since 4 >= 0 ),
 and return the value 
\begin_inset Quotes eld
\end_inset

Have butter!
\begin_inset Quotes erd
\end_inset

.
 This in turn gets assigned to variable result.
\end_layout

\begin_layout Subsubsection*
Case Classes
\end_layout

\begin_layout Standard
Case Classes are classes that get a few extras thrown in.
 We get succinct field definitions plus a constructor wrapped into one statement.
\end_layout

\begin_layout LyX-Code
case class Player(name:
 String,
 age:
 Int)
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

val mario = Person(
\begin_inset Quotes eld
\end_inset

Mario Menendez
\begin_inset Quotes erd
\end_inset

,
 27)
\end_layout

\begin_layout LyX-Code
val luigi = Persion(
\begin_inset Quotes eld
\end_inset

Luigi Verdi
\begin_inset Quotes erd
\end_inset

,
 29)
\end_layout

\begin_layout Standard
With this single declaraction,
 we get a class we can instantiate quickly.
 We also get built in operations for things like comparison,
 pretty-printing and copying.
\end_layout

\begin_layout LyX-Code
if (mario.age != luigi.age)
\end_layout

\begin_layout LyX-Code
  println(
\begin_inset Quotes erd
\end_inset

Not the same age!
\begin_inset Quotes erd
\end_inset

) // notice no s
\begin_inset Quotes erd
\end_inset


\begin_inset Quotes erd
\end_inset

 since no substitution required
\end_layout

\begin_layout Subsubsection*
Collections & Comprehensions
\end_layout

\begin_layout Standard
Lists are declared as you would expect:
\end_layout

\begin_layout LyX-Code
val numbers = List(1,
 2,
 3)
\end_layout

\begin_layout Standard
The magic comes from 
\emph on
comprehensions
\emph default
:
\end_layout

\begin_layout LyX-Code
val doubled = 
\series bold
for
\series default
 n 
\series bold
<-
\series default
 numbers 
\series bold
yield
\series default
 n * 2
\end_layout

\begin_layout Standard
For those unfamiliar,
 comprehensions operate on the *entire list*,
 and return (usually) an updated list with each element altered by the value the code block 
\emph on
yields
\emph default
.
 So in this case,
 we get a list of the form List(2,
 4,
 6).
\end_layout

\begin_layout Standard
You can see the syntax here,
 albeit a bit out of order from normal:
\end_layout

\begin_layout Standard
- the statement starts with a _for_
\end_layout

\begin_layout Standard
- the 
\begin_inset Quotes eld
\end_inset

n
\begin_inset Quotes erd
\end_inset

 defines a parameter that will take the value of each element of the list at a time
\end_layout

\begin_layout Standard
- for each element,
 we then execute the code to the right of the 
\begin_inset Quotes eld
\end_inset

<-
\begin_inset Quotes erd
\end_inset

 operator
\end_layout

\begin_layout Standard
- the 
\begin_inset Quotes eld
\end_inset

yield
\begin_inset Quotes erd
\end_inset

 statement says,
 for each element in the loop,
 return this new value (in this case n * 2)
\end_layout

\begin_layout Standard
So,
 in effect,
 we say 
\end_layout

\begin_layout LyX-Code

\series bold
for
\series default
 
\emph on
i
\emph default
 
\series bold
<-
\series default
 
\emph on
list_variable
\end_layout

\begin_layout LyX-Code
  ...
 do some calculations ...
\end_layout

\begin_layout LyX-Code
  
\series bold
yield
\series default
 
\emph on
some_value // for each element in list_variable
\end_layout

\begin_layout Standard
...
 and that's it!
 This combination of features really does yield a powerful set of capabilities.
\end_layout

\begin_layout Subsection*
And Beyond...
\end_layout

\begin_layout Standard
A common use case for scala is to deal with data.
 Here's a what a small db interaction looks like:
\end_layout

\begin_layout LyX-Code
package io.startup.api
\end_layout

\begin_layout LyX-Code
import sttp.client3.* // Wildcard import
\end_layout

\begin_layout LyX-Code
import doobie.* // Database tools
\end_layout

\begin_layout LyX-Code
import doobie.implicits.* // Magic "glue" for SQL
\end_layout

\begin_layout LyX-Code
// A Trait that defines "State" for our database access
\end_layout

\begin_layout LyX-Code
trait DBConfig:
\end_layout

\begin_layout LyX-Code
  val xa = Transactor.fromDriverManager[IO](
\end_layout

\begin_layout LyX-Code
    "org.postgresql.Driver",
 "jdbc:postgresql:db",
 "user",
 "pass"
\end_layout

\begin_layout LyX-Code
  )
\end_layout

\begin_layout LyX-Code
// A Case Class for our data
\end_layout

\begin_layout LyX-Code
case class Product(id:
 Int,
 name:
 String)
\end_layout

\begin_layout LyX-Code
// Our main logic mixing it all in
\end_layout

\begin_layout LyX-Code
object ProductService extends DBConfig:
\end_layout

\begin_layout LyX-Code
  def getProduct(id:
 Int) = 
\end_layout

\begin_layout LyX-Code
    sql"select id,
 name from products where id = $id"
\end_layout

\begin_layout LyX-Code
      .query[Product]
\end_layout

\begin_layout LyX-Code
      .unique
\end_layout

\begin_layout LyX-Code
      .transact(xa)
\end_layout

\begin_layout Standard
Our solution makes use of the sttp client library and the doobie database tools (magic).
\end_layout

\begin_layout Section
Classes & Objects
\end_layout

\begin_layout Standard
So scala prides itself on being a union of 2,
 equally well execute patterns.
 The intuition here may be that one must be prioritized over the other.
 Let's take a deeper look.
\end_layout

\begin_layout Standard
In scala,
 we can create a basic class:
\end_layout

\begin_layout LyX-Code
class Company(val name:
 String,
 val revenue:
 Int)
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

val myCompany = Company(
\begin_inset Quotes eld
\end_inset

saas-o-rama
\begin_inset Quotes erd
\end_inset

,
 7000)
\end_layout

\begin_layout LyX-Code
pprint.pprintln(myCompany) -> hello$_$Company@6d8a00e3
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout Standard
That seemed to go well.
 We are using Li Haoyi's default 
\begin_inset Quotes eld
\end_inset

pprint
\begin_inset Quotes erd
\end_inset

 libary (which we added in project.scala) which gives a raw dump of the object.
 
\end_layout

\begin_layout Standard
We can do better,
 though.
 Let's override the toString method and give something a bit more useful:
\end_layout

\begin_layout LyX-Code
class Company(val name:
 String,
 val revenue:
 Int):
\end_layout

\begin_layout LyX-Code
  override def toString:
 String = 
\end_layout

\begin_layout LyX-Code
    s"[Company:
 $name | MRR:
 $$$revenue]"
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

val myCompany = Company(
\begin_inset Quotes eld
\end_inset

saas-o-rama
\begin_inset Quotes erd
\end_inset

,
 7000)
\end_layout

\begin_layout LyX-Code
pprint.pprintln(myCompany) -> [Company:
 saas-o-rama | MRR:
 $7000]
\end_layout

\begin_layout Subsection*
Inheritance
\end_layout

\begin_layout Standard
Inheritance is the most well-known mechanism that allows us to create specialization of classes:
\end_layout

\begin_layout LyX-Code
class StartupCompany(name:
 String,
 revenue:
 Int,
 seedMoney:
 Int) extends Company(name,
 revenue):
\end_layout

\begin_layout LyX-Code
  override def toString:
 String =
\end_layout

\begin_layout LyX-Code
    s"[Startup Company:
 $name | Seed:
 $$$seedMoney | MRR:
 $$$revenue]"
\end_layout

\begin_layout Standard
This defines a new class,
 StartupCompany,
 which is a specialization of Company that takes seedMoney (since most startups need some capital to get going).
\end_layout

\begin_layout Standard
Looking at an instance of the new class we find:
\end_layout

\begin_layout LyX-Code
val myCompany = StartupCompany("startup-o-rama",
 7000,
 80000)
\end_layout

\begin_layout LyX-Code
pprint.pprintln(myCompany)  // -->  [Startup Company:
 startup-o-rama | Seed:
 $80000 | MRR:
 $7000]
\end_layout

\begin_layout Standard
So we see the toString method returns the override value.
 We can also make use of the inherited version in our result:
\end_layout

\begin_layout LyX-Code
class StartupCompany(name:
 String,
 revenue:
 Int,
 seedMoney:
 Int) extends Company(name,
 revenue):
\end_layout

\begin_layout LyX-Code
  override def toString:
 String =
\end_layout

\begin_layout LyX-Code
    val p = super.toString()
\end_layout

\begin_layout LyX-Code
    s"[Startup Company:
 $name | Seed:
 $$$seedMoney | MRR:
 $$$revenue] (was $p)"
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
val myCompany = StartupCompany("startup-o-rama",
 7000,
 80000)
\end_layout

\begin_layout LyX-Code
pprint.pprintln(myCompany)  // --> 
\end_layout

\begin_layout LyX-Code
  [Startup Company:
 startup-o-rama | Seed:
 $80000 | MRR:
 $7000] (was [Company:
 startup-o-rama | MRR:
 $7000])
\end_layout

\begin_layout Subsection*
Objects and Attributes
\end_layout

\begin_layout Standard
So,
 you may have noticed one of the first shorthands that scala offers that many languages don't.
 In Company,
 we simply defin name & revenue in class signature and get a few things at once:
 a class name assigned,
 attributes defined in a single place (they look like parameters here),
 and assignment of values(those passed into constructor).
 That is,
 when I say
\end_layout

\begin_layout LyX-Code
class Company(val name:
 String,
 var revenue:
 Int)
\end_layout

\begin_layout Standard
We know that the values passed in will be assigned to the members 
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

 & 
\begin_inset Quotes eld
\end_inset

revenue
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout LyX-Code
val c = Company(
\begin_inset Quotes eld
\end_inset

hi
\begin_inset Quotes erd
\end_inset

,
 200000)
\end_layout

\begin_layout LyX-Code
c.name // 
\begin_inset Quotes eld
\end_inset

hi
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
And as a bonus,
 if you declare a parameter with 
\begin_inset Quotes eld
\end_inset

var
\begin_inset Quotes erd
\end_inset

,
 you get both getter and setter methods:
\end_layout

\begin_layout LyX-Code
c.revenue = 40000
\end_layout

\begin_layout LyX-Code
c.revenue // 40000
\end_layout

\begin_layout Subsection*
Companion Objects [ aka Mixins ]
\end_layout

\begin_layout Standard
So far we have just explored class use case where where we *instantiate* a class to get new objects [ eg.
 Company(
\begin_inset Quotes eld
\end_inset

hi,
 200000) ].
\end_layout

\begin_layout Standard
In scala,
 however,
 there is more to this pattern.
 We can create singleton *companion objects* to a class.
 This allows us to define global methods and data we can use to coordinate class instantiation and other tasks.
 For example,
 consider our Company class again from above:
\end_layout

\begin_layout LyX-Code
class Company(val name:
 String,
 val revenue:
 Int):
\end_layout

\begin_layout LyX-Code
  override def toString:
 String = 
\end_layout

\begin_layout LyX-Code
    s"[Company:
 $name | MRR:
 $$$revenue]"
\end_layout

\begin_layout Standard
What if we wanted to have some global state and/or methods that could operate on our class to do things like create instances for us (rather than directly instantiating)?
 Well in scala,
 we can coordinate using a 
\series bold
companion object:
\end_layout

\begin_layout LyX-Code
object Company:
\end_layout

\begin_layout LyX-Code
  def buildOne(name:
 String) :
 Company =
\end_layout

\begin_layout LyX-Code
    val c = new Company(name,
 0)
\end_layout

\begin_layout LyX-Code
    println(
\begin_inset Quotes eld
\end_inset

we build a new company!
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout LyX-Code
    c
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
// Use the new companion to build a new company
\end_layout

\begin_layout LyX-Code
newCo = Company.buildOne(
\begin_inset Quotes eld
\end_inset

Funco
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard
Now,
 we need to be clear here.
 The 
\begin_inset Quotes eld
\end_inset

Company
\begin_inset Quotes erd
\end_inset

 used to invoke 
\begin_inset Quotes eld
\end_inset

buildOne
\begin_inset Quotes erd
\end_inset

 on the last line refers to the Company *object*.
 The rest of the 
\begin_inset Quotes eld
\end_inset

Company
\begin_inset Quotes erd
\end_inset

s refer to the Company class (such as the return type of the buildOne method,
 as well as the 
\begin_inset Quotes eld
\end_inset

new
\begin_inset Quotes erd
\end_inset

 instantiation within the 
\begin_inset Quotes eld
\end_inset

buildOne
\begin_inset Quotes erd
\end_inset

 method.
 But this allows us to implement the factory pattern,
 giving us control over the conditions under which Company (class) is created.
\end_layout

\begin_layout Standard
Companiuon/singleton objects also allow us to get/set global state:
\end_layout

\begin_layout LyX-Code
object AppConfig:
\end_layout

\begin_layout LyX-Code
  val apiBase = "https://api.startup.io"
\end_layout

\begin_layout LyX-Code
  var debugMode = true
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
// Accessible anywhere without 'new'
\end_layout

\begin_layout LyX-Code
if AppConfig.debugMode then println(s"Connecting to ${AppConfig.apiBase}")
\end_layout

\begin_layout Section
Collections,
 Blocks & Iterators
\end_layout

\begin_layout Standard
Scala owns performance and in particular big data.
 So it makes sense that collections would be where it outshines most other languages.
 
\end_layout

\begin_layout Standard
There are 3 basic,
 big-name collections:
 lists,
 vectors,
 and maps.
 
\end_layout

\begin_layout Subsection*
Lists
\end_layout

\begin_layout Standard
Lists hold collections of objects (object references if you want to be specific),
 with each object occupying a position in the array at a given *index* (eg.
 0,
 1,
 2...n).
 They are the break and butter for small to medium sized data sets.
\end_layout

\begin_layout Standard
Lists by default are *immutable*,
 meaning they can't be added to.
 The pattern if we need to update a list is to create a new one that is a copy of the existing + given new elements.
\end_layout

\begin_layout LyX-Code
val fruit = List("Apple",
 "Banana",
 "Cherry")
\end_layout

\begin_layout LyX-Code
var pickOne = fruit(0) // Returns 
\begin_inset Quotes eld
\end_inset

Apple
\begin_inset Quotes erd
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

val moreFruit = 
\begin_inset Quotes eld
\end_inset

Dragonfruit
\begin_inset Quotes erd
\end_inset

 ::
 fruit
\end_layout

\begin_layout LyX-Code
val changeCherry = fruit.updated(2,
 
\begin_inset Quotes eld
\end_inset

Kiwi
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard
Note the use of 
\begin_inset Quotes eld
\end_inset

()
\begin_inset Quotes erd
\end_inset

 syntax to get element,
 rather than 
\begin_inset Quotes eld
\end_inset

[]
\begin_inset Quotes erd
\end_inset

 in other languages.
 This is one of the beauties of scala but also why some folks coming from other languages label it as 
\begin_inset Quotes eld
\end_inset

hard
\begin_inset Quotes erd
\end_inset

:
 it is not afraid to break conventions of other languages (*cough* C *cough*).
\end_layout

\begin_layout Standard
Also,
 we add an element by creating a new list with the changes:
 we can create a new list with the new value added (in this case we prepend),
 the new value substituted into a given index,
 or an old value dropped.
\end_layout

\begin_layout LyX-Code
val noFirstFruit = fruit.drop(1) // drops everything to the left of the given index
\end_layout

\begin_layout LyX-Code
val noLastFruit = fruit.dropRight(1) // drops everything to the right of the given index
\end_layout

\begin_layout LyX-Code
val dropBananaAddCitruses =  fruit.patch(1,
 List(
\begin_inset Quotes eld
\end_inset

lemon
\begin_inset Quotes erd
\end_inset

,
 
\begin_inset Quotes eld
\end_inset

lime
\begin_inset Quotes erd
\end_inset

),
 1) // remove banana,
 add more citrus in the middle
\end_layout

\begin_layout Standard
Note:
 obj.patch(fromIndex,
 replacementCollection,
 numberOfElementsToRemove) combines a few of these into one,
 where we give it an index & number of elements to remove,
 as well as an optional new list to insert.
\end_layout

\begin_layout Standard
This approach encourages mapping operations & comprehensive changes (which we will discuss in a minute) over one-offs.
\end_layout

\begin_layout Subsection*
Maps (Hashes)
\end_layout

\begin_layout Standard
Hashes are collections where the elements are indexed by a key that can be any type of object or values (not necessarily integers in order):
\end_layout

\begin_layout LyX-Code
val meal = Map(
\begin_inset Quotes eld
\end_inset

main course
\begin_inset Quotes erd
\end_inset

 -> "lobster",
 
\begin_inset Quotes eld
\end_inset

appetizer
\begin_inset Quotes erd
\end_inset

 -> "escargots",
 
\begin_inset Quotes eld
\end_inset

dessert
\begin_inset Quotes erd
\end_inset

 -> 
\begin_inset Quotes eld
\end_inset

chocolate cake
\begin_inset Quotes erd
\end_inset

)
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

val appies = meal(
\begin_inset Quotes eld
\end_inset

appetizer
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard
Notice that there's no sequencing requirement.
 The only constraint is that keys must be of the same type.
\end_layout

\begin_layout Subsection*
Vectors
\end_layout

\begin_layout Standard
Vectors list lists,
 but are optimized for *random-access*,
 as opposed to iteration.
 That is to say,
 even if your collection is enormous,
 if you need the middle element you can jump there immediately.
\end_layout

\begin_layout LyX-Code
val trees = Vector(
\begin_inset Quotes eld
\end_inset

pine
\begin_inset Quotes erd
\end_inset

,
 
\begin_inset Quotes eld
\end_inset

birch
\begin_inset Quotes erd
\end_inset

,
 
\begin_inset Quotes eld
\end_inset

maple
\begin_inset Quotes erd
\end_inset

)
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

val whitey = trees(trees.length / 2) // Grab middle element
\end_layout

\begin_layout Standard
This may seem unimpressive,
 but as data sets grow large,
 the last statement will typically perform better with a vector than a list.
\end_layout

\begin_layout Subsection*
Blocks (aka 
\begin_inset Quotes eld
\end_inset

Higher Order Functions
\begin_inset Quotes erd
\end_inset

) & Iterators
\end_layout

\begin_layout Standard
Now,
 imagine that we have a list of company objects (see above).
 Let's create a company list class for some common operations on company lists:
\end_layout

\begin_layout LyX-Code
class CompanyList(companies:
 List[Company])
\end_layout

\begin_layout LyX-Code
  def withBrand(brand:String):Option[Company] =
\end_layout

\begin_layout LyX-Code
    companies.find { c =>
\begin_inset Newline newline
\end_inset

      c.name == brand
\begin_inset Newline newline
\end_inset

    }
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

// Use it!
\begin_inset Newline newline
\end_inset

val c = CompanyList( List(Company("Nike",
 10),
 Company("Reebok",
 20)) )
\begin_inset Newline newline
\end_inset

c.withBrand { "Reebok" }
\end_layout

\begin_layout Standard
Note that in withBrand we are take a brand name,
 and then execute the 
\begin_inset Quotes eld
\end_inset

find
\begin_inset Quotes erd
\end_inset

 method with a strange iterator 
\emph on
code block
\emph default
 attached:
\end_layout

\begin_layout Standard
- the 
\begin_inset Quotes eld
\end_inset

 c => 
\begin_inset Quotes eld
\end_inset

 syntax says 
\begin_inset Quotes eld
\end_inset

for each element in the collection,
 assign it to the variable defined left of the 
\begin_inset Quotes eld
\end_inset

=>
\begin_inset Quotes erd
\end_inset

 (in this case 'c'),
 
\end_layout

\begin_layout Standard
- then run the chunk of code after the 
\begin_inset Quotes eld
\end_inset

=>
\begin_inset Quotes erd
\end_inset

 for each element in the collection
\end_layout

\begin_layout Standard
What happens with the result of this block depends on the method it's used for.
 In this case,
 it's expected to return a boolean value,
 and will return the first element where the code block returns true.
 [ Well that's not quite true actually – it will return a value of Some[
\emph on
value
\emph default
] ( or None if no elements are found ) ]
\end_layout

\begin_layout Standard
NOTE:
 another quick thing to notice here is that there is no 
\begin_inset Quotes eld
\end_inset

return
\begin_inset Quotes erd
\end_inset

 statement here.
 That's basically a convenience measure for clarity,
 where the method takes the last statement of it's call chain and assumes that is what it should return.
\end_layout

\begin_layout Standard
We could also generalize this statement and allow *any* code block to be taken to evaluate against the list to find an element:
\end_layout

\begin_layout LyX-Code
  def findFlex(block:
 Company => Boolean):Option[Company] =
\end_layout

\begin_layout LyX-Code
    companies.find { c => 
\begin_inset Newline newline
\end_inset

      block(c)
\begin_inset Newline newline
\end_inset

    }
\end_layout

\begin_layout Standard
Notice how the parameter is defined here:
 
\end_layout

\begin_layout LyX-Code
block:
 Company => Boolean
\end_layout

\begin_layout Standard
This tells the method the parameter is named block,
 and it expects a code block that will take a Company as a parameter and return a boolean result.
\end_layout

\begin_layout Standard
We can then invoke it with:
\end_layout

\begin_layout LyX-Code
c.findFlex { c => c.name == "Reebok" }
\end_layout

\begin_layout Standard
NOTE:
 Many language stop here,
 but scala actually refines this further with a convenient shorthand syntax,
 where we can use underscore ( 
\begin_inset Quotes eld
\end_inset

_
\begin_inset Quotes erd
\end_inset

 ) to mean the current element in our iteration.
 So the above would become:
\end_layout

\begin_layout LyX-Code
c.findFlex { _.name == "Reebok" }
\end_layout

\begin_layout Section
Standard Types
\end_layout

\begin_layout Subsection*
Numbers
\end_layout

\begin_layout Standard
Numbers are one of the aspects of scala that show it's more than just a scripting language.
 It's an artifact of the language's underlying relationship to the jvm,
 and honestly reflects the fact that some choices should not be abstracted away in order that we may keep code optimized.
\end_layout

\begin_layout Standard
tldr;
 - We still need to articulate what kind of a number we are dealing with,
 be super-short (byte randing from -128 to 127) or super-big (bigint which can make numbers as large as your RAM will allow).
\end_layout

\begin_layout Standard
For integers,
 the usual choices are either Int or Long.
 For decimeals we have either Float or Double (depending on whether you need floating point or strict decimal places).
\end_layout

\begin_layout Subsection*
Strings
\end_layout

\begin_layout Standard
Strings basically can be either single-character (Char) or actual string (see java.lang.String).
 Note though that in scala we get over 200 additional methods baked into the string type.
\end_layout

\begin_layout Standard
Literal values can be with single quotes ('a' character),
 double quotes (
\begin_inset Quotes eld
\end_inset

Hi there
\begin_inset Quotes erd
\end_inset

) or multiline with triple quotes (
\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset


\begin_inset Quotes erd
\end_inset

 hi there 
\begin_inset Quotes eld
\end_inset


\begin_inset Quotes erd
\end_inset


\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Standard
For mutliline strings,
 we can use the pipe symbol ( | ) combined with the stripMargin method to negate the indentation prior to the pipes.
 So 
\end_layout

\begin_layout LyX-Code
val html = """<html>
\end_layout

\begin_layout LyX-Code
             | <body>Hello</body>
\end_layout

\begin_layout LyX-Code
             |</html>""".stripMargin
\end_layout

\begin_layout Standard
basically renders the html block properly,
 which allowing us to indent in the code for readability.
\end_layout

\begin_layout Standard
We also get some nice interpolation options for string literals.
 In particular s
\begin_inset Quotes erd
\end_inset

value $var
\begin_inset Quotes erd
\end_inset

 to allow variable values and f
\begin_inset Quotes erd
\end_inset

Var is around $var%.2f
\begin_inset Quotes erd
\end_inset

 to allow variable values while controlling their formatting.
\end_layout

\begin_layout LyX-Code
val name = "Renaissance"
\end_layout

\begin_layout LyX-Code
println(s"Welcome to $name version ${1 + 1}")
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

val pi = 3.14159
\end_layout

\begin_layout LyX-Code
println(f"Pi is roughly $pi%.2f") // "Pi is roughly 3.14"
\end_layout

\begin_layout Subsection*
Ranges
\end_layout

\begin_layout Standard
Ranges are basically an abstration of lists of predetermined values that allow some useful operations while not strictly storing the entire list in memory.
\end_layout

\begin_layout LyX-Code
var alphabet = 'a' to 'z'
\end_layout

\begin_layout Standard
We can also add a 
\begin_inset Quotes eld
\end_inset

 by 
\begin_inset Quotes eld
\end_inset

 clause to progress by given increments when we iterate:
\end_layout

\begin_layout LyX-Code
val odds = 1 to 10 by 2       // 1,
 3,
 5,
 7,
 9
\end_layout

\begin_layout Standard
Note that 
\begin_inset Quotes eld
\end_inset

until
\begin_inset Quotes erd
\end_inset

 is similar to 
\begin_inset Quotes eld
\end_inset

 to 
\begin_inset Quotes eld
\end_inset

,
 except it excludes the final number
\end_layout

\begin_layout LyX-Code
var alphabet = 'a' to 'z'      // a,
 b,
 c,
 d,
 ...
 y,
 z
\end_layout

\begin_layout LyX-Code
var alphabet = 'a' until 'z'   // a,
 b,
 c,
 d,
 ...
 y
\end_layout

\begin_layout Standard
Ranges can of course to turned into lists if we need,
 since there is a lot more you can do to manipulate a list ( they are just a little more verbose to deal with code-wise ):
\end_layout

\begin_layout LyX-Code
val list = (1 to 5).toList     // List(1,
 2,
 3,
 4,
 5)
\end_layout

\begin_layout Subsection*
Regular Expressions
\end_layout

\begin_layout Standard
Regular expressions are mostly created by defining them in a string and using the 
\begin_inset Quotes eld
\end_inset

r
\begin_inset Quotes erd
\end_inset

 method to convert to regex:
\end_layout

\begin_layout LyX-Code
val EmailRegex = """([a-zA-Z0-9.-]+)@([a-zA-Z0-9.-]+
\backslash
.[a-zA-Z]{2,4})""".r
\end_layout

\begin_layout Standard
We can then use these in match statements to handle cases against string:
\end_layout

\begin_layout LyX-Code
val input = "Contact us at support@startup.io"
\end_layout

\begin_layout LyX-Code
input match
\end_layout

\begin_layout LyX-Code
  case EmailRegex(user,
 domain) => 
\end_layout

\begin_layout LyX-Code
    println(s"User:
 $user,
 Domain:
 $domain")
\end_layout

\begin_layout LyX-Code
  case _ => 
\end_layout

\begin_layout LyX-Code
    println("No email found.")
\end_layout

\begin_layout Standard
Unlike in other languages,
 regex objects get methods you can invoke directly on them :
\end_layout

\begin_layout LyX-Code
val text = "We have 10 apples and 20 oranges"
\end_layout

\begin_layout LyX-Code
val NumberRegex = """(
\backslash
d+)""".r
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
val firstNum = NumberRegex.findFirstIn(text) // Some("10")
\end_layout

\begin_layout LyX-Code
val allNums  = NumberRegex.findAllIn(text).toList // List("10",
 "20")
\end_layout

\begin_layout Standard
In particular,
 one method that is often useful is the replacement method:
\end_layout

\begin_layout LyX-Code
val rawPath = "user/profile/settings"
\end_layout

\begin_layout LyX-Code
val result = """/""".r.replaceAllIn(rawPath,
 " -> ") 
\end_layout

\begin_layout LyX-Code
// Result:
 "user -> profile -> settings"
\end_layout

\begin_layout Subsection*
Other
\end_layout

\begin_layout Standard
A quick note that 
\begin_inset Quotes eld
\end_inset

Any
\begin_inset Quotes erd
\end_inset

 data type can be used when you want to allow a variable to take any type of value.
 Matching can then be done to handle based on type:
\end_layout

\begin_layout LyX-Code
def process(input:
 Any):
 Unit = input match
\end_layout

\begin_layout LyX-Code
  case s:
 String => println(s"Got a string:
 $s")
\end_layout

\begin_layout LyX-Code
  case i:
 Int    => println(s"Got a number:
 $i")
\end_layout

\begin_layout LyX-Code
  case _         => println("Got something else")
\end_layout

\begin_layout Section
Method Madness
\end_layout

\begin_layout Standard
When defining methods on classes in scala,
 there are several nuances that will allow cleaner AND more robust code.
\end_layout

\begin_layout Subsection*
Variable Length Arguments
\end_layout

\begin_layout Standard
A method can take in many arguments of a given type by using the '*' syntax.
 The resulting parameter will be treated as a sequence:
\end_layout

\begin_layout LyX-Code
def printAll(names:
 String*):
 Unit =
\end_layout

\begin_layout LyX-Code
  names.foreach(name => println(s"Hello,
 $name"))
\end_layout

\begin_layout LyX-Code
// Usage:
\end_layout

\begin_layout LyX-Code
printAll("Alice")
\end_layout

\begin_layout LyX-Code
printAll("Alice",
 "Bob",
 "Charlie")
\end_layout

\begin_layout LyX-Code
printAll() // You can even pass nothing;
 it becomes an empty Seq
\end_layout

\begin_layout Standard
You can also 
\begin_inset Quotes eld
\end_inset

explode
\begin_inset Quotes erd
\end_inset

 collections into these arguments:
\end_layout

\begin_layout LyX-Code
val developers = List("Scala",
 "Python",
 "Rust")
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
// printAll(developers) // ERROR:
 Expected String,
 found List
\end_layout

\begin_layout LyX-Code
printAll(developers:
 _*) // SUCCESS:
 Splats the list into individual strings
\end_layout

\begin_layout Standard
Please note the variable length argument must be the last in the signature,
 and have to be of a specified type.
\end_layout

\begin_layout Standard
Another trick we can do if we want to allow arbitrary hash options to be passed is to use Varargs with Tuples:
\end_layout

\begin_layout LyX-Code
def bulkUpdate(pairs:
 (String,
 String)*):
 Unit =
\end_layout

\begin_layout LyX-Code
  val dataMap = pairs.toMap // Convert those pairs into a Hash Map
\end_layout

\begin_layout LyX-Code
  println(s"Updating ${dataMap.size} fields...")
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
// Usage:
 Look how clean this is!
\end_layout

\begin_layout LyX-Code
bulkUpdate(
\end_layout

\begin_layout LyX-Code
  "email" -> "alice@startup.io",
\end_layout

\begin_layout LyX-Code
  "status" -> "active",
\end_layout

\begin_layout LyX-Code
  "plan"   -> "pro"
\end_layout

\begin_layout LyX-Code
)
\end_layout

\begin_layout Standard
The '*' makes it variable length,
 while the '(String,
 String)' means it takes pairs (Tuples).
 Quite a useful idiom.
\end_layout

\begin_layout Section
Expressions
\end_layout

\begin_layout Standard
Like many other scripting languages,
 scala allows to alter methods at a pretty profound level.
 You can override '+' operator.
\end_layout

\begin_layout LyX-Code
case class Position(x:
 Int,
 y:
 Int):
\end_layout

\begin_layout LyX-Code
  // Define the '+' method
\end_layout

\begin_layout LyX-Code
  def +(other:
 Position):
 Position =
\end_layout

\begin_layout LyX-Code
    Position(this.x + other.x,
 this.y + other.y)
\end_layout

\begin_layout LyX-Code
val p1 = Position(10,
 20)
\end_layout

\begin_layout LyX-Code
val p2 = Position(5,
 5)
\end_layout

\begin_layout LyX-Code
// Now you can use it like a native operator!
\end_layout

\begin_layout LyX-Code
val p3 = p1 + p2 
\end_layout

\begin_layout LyX-Code
// Result:
 Position(15,
 25)
\end_layout

\begin_layout Standard
This was a little surprising to us when we first realized this,
 but allows for the same level of customization usually reserved for scripting languages like Ruby.
\end_layout

\begin_layout Standard
As mentioned earlier,
 parallel assignment is also supported in scala:
\end_layout

\begin_layout LyX-Code
val (success,
 fail) = (res.getOrElse("ok",
 0),
 res.getOrElse("error",
 0))
\end_layout

\begin_layout Subsection*
Conditionals
\end_layout

\begin_layout Standard
scala makes extensive use of options to get around null values.
 We use the 
\begin_inset Quotes eld
\end_inset

Elvis-style
\begin_inset Quotes erd
\end_inset

 operators to get values from options,
 specifying 
\begin_inset Quotes eld
\end_inset

coalescing
\begin_inset Quotes erd
\end_inset

 type default values if the option is 
\begin_inset Quotes eld
\end_inset

None
\begin_inset Quotes erd
\end_inset

:
\end_layout

\begin_layout LyX-Code
val storedName:
 Option[String] = None
\end_layout

\begin_layout LyX-Code
// Instead of:
 name ||= "Default"
\end_layout

\begin_layout LyX-Code
val name = storedName.getOrElse("Guest")
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

if guards
\begin_inset Quotes erd
\end_inset

 s allow us to modify several data structures to skip execution in the given condition
\end_layout

\begin_layout Standard
TODO:
 ^^– fill this in
\end_layout

\begin_layout Subsection*
Case Expressions ( aka Matching )
\end_layout

\begin_layout Standard
We have now reached a pivotal moment.
 Case expressions are one of the defining features of scala.
\end_layout

\begin_layout Standard
The syntax is deceptively simple:
\end_layout

\begin_layout LyX-Code

\emph on
input_expression
\emph default
 
\series bold
match
\series default
  
\end_layout

\begin_layout LyX-Code
  
\series bold
case
\series default
 
\emph on
case_condition_1
\emph default
    => 
\emph on
action_block_1
\end_layout

\begin_layout LyX-Code
  
\series bold
case
\series default
 
\emph on
case_condition_2
\emph default
    => 
\emph on
action_block_2
\end_layout

\begin_layout LyX-Code
  ...
\end_layout

\begin_layout LyX-Code
  
\series bold
case
\series default
 _                   => 
\emph on
default_action_block
\end_layout

\begin_layout Standard
The input_expression is an expression that will be evaluated.
\end_layout

\begin_layout Standard
Each case condition is then compared to the input_expression (in the same way a regular expression is compared to a string).
 The code/action block associated with the first case condition that matches is what gets executed,
 and the result of the block is returned.
 
\end_layout

\begin_layout Standard
The input_expression can be virtually any variable or value,
 and the case conditions are quite varied,
 enabling anything from a simple match on class types to matches on specific attributes of objects.
 And each case can be a unique category – one condition may match on type,
 whereas the next may match on a value.
 Let's look at an example:
\end_layout

\begin_layout LyX-Code
val toTest:
 
\series bold
Any
\series default
 = "Success"
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
toTest 
\series bold
match
\end_layout

\begin_layout LyX-Code
  
\series bold
case
\series default
 0            => println("It's a zero")       // Constant match
\end_layout

\begin_layout LyX-Code
  
\series bold
case
\series default
 "Success"    => println("It's a win!")        // String match
\end_layout

\begin_layout LyX-Code
  
\series bold
case
\series default
 s:
 String    => println(s"It's a string:
 $s") // Type match
\end_layout

\begin_layout LyX-Code
  
\series bold
case
\series default
 _            => println("Fallback")           // Wildcard (catch-all)
\end_layout

\begin_layout Standard
Notice that the first case_condition is a comparison to see if the value of match is '0'.
 Even though this is an integer,
 the comparison is fine and will simply return a false,
 moving to the next case.
\end_layout

\begin_layout Standard
Subsequent case conditions are:
 comparison to see if the value is 
\begin_inset Quotes eld
\end_inset

Success
\begin_inset Quotes erd
\end_inset

 (which it actually is),
 comparison to type to see if it's a string,
 and then the default catch all.
 
\end_layout

\begin_layout Standard
Notice as well that the action blocks are simply printing output and not returning any result.
 This is perfectly fine,
 burt we can also do more:
\end_layout

\begin_layout LyX-Code

\series bold
val
\series default
 status = 404
\end_layout

\begin_layout LyX-Code

\series bold
val
\series default
 message = status 
\series bold
match
\end_layout

\begin_layout LyX-Code
  
\series bold
case
\series default
 200 => "OK"
\end_layout

\begin_layout LyX-Code
  
\series bold
case
\series default
 404 => "Not Found"
\end_layout

\begin_layout LyX-Code
  
\series bold
case
\series default
 500 => "Internal Server Error"
\end_layout

\begin_layout LyX-Code
  
\series bold
case
\series default
 _   => "Unknown Status"
\end_layout

\begin_layout LyX-Code
println(message) // "Not Found"
\end_layout

\begin_layout Standard
Notice the we have a match expression,
 and then we are assigning the output to a val variable.
 This is often the preferred method of usage,
 when possible.
\end_layout

\begin_layout Standard
Now,
 as we mentioned,
 we can match on classes and attribute values,
 using 
\emph on
destructuring
\emph default
 to match on the 
\begin_inset Quotes eld
\end_inset

insides
\begin_inset Quotes erd
\end_inset

 of a class.
 In fact,
 we can combine these as follows:
\end_layout

\begin_layout LyX-Code
case class User(name:
 String,
 role:
 String)
\end_layout

\begin_layout LyX-Code
val user = User("Alice",
 "Admin")
\end_layout

\begin_layout LyX-Code
user 
\series bold
match
\end_layout

\begin_layout LyX-Code
  
\series bold
case
\series default
 
\series bold
\emph on
User("Alice",
 _)
\series default
\emph default
      => println("Found Alice,
 regardless of role")
\end_layout

\begin_layout LyX-Code
  
\series bold
case
\series default
 
\series bold
\emph on
User(name,
 "Admin")
\series default
\emph default
   => println(s"Found an Admin named $name")
\end_layout

\begin_layout LyX-Code
  
\series bold
case
\series default
 
\series bold
\emph on
User(name,
 role)
\series default
\emph default
      => println(s"Found $name who is a $role")
\end_layout

\begin_layout Standard
So this is where things start to diverge from the norm a bit.
 We can see int he first case,
 we are saying 
\begin_inset Quotes eld
\end_inset

match on when the input_expression when it's a User and the name is 'Alice'
\begin_inset Quotes erd
\end_inset

.
 We don't care what the role is ( hence the 
\begin_inset Quotes eld
\end_inset

_
\begin_inset Quotes erd
\end_inset

 ).
 
\end_layout

\begin_layout Standard
Notice that when we add a variable name to the destructured class in the case condition,
 we get the matching value assigned into a variable of that name that we can use in the corresponding action block.
\end_layout

\begin_layout Standard
Scala takes this even further down the functional road,
 enabling matching on the shape of lists:
\end_layout

\begin_layout LyX-Code
val list = List(1,
 2,
 3)
\end_layout

\begin_layout LyX-Code
list 
\series bold
match
\end_layout

\begin_layout LyX-Code
  
\series bold
case
\series default
 Nil               => "Empty list"
\end_layout

\begin_layout LyX-Code
  
\series bold
case
\series default
 List(x)           => s"Only one element:
 $x"
\end_layout

\begin_layout LyX-Code
  
\series bold
case
\series default
 head ::
 tail      => s"Starts with $head,
 followed by $tail"
\end_layout

\begin_layout LyX-Code
  
\series bold
case
\series default
 List(1,
 _*)       => "Starts with 1 and has other stuff"
\end_layout

\begin_layout Standard
Notice now this is quite flexible,
 allowing comparison even to 
\series bold
Nil 
\series default
in the first case,
 but then matching on the 'single element list' shape,
 a list with a head and then tail elements,
 and even a mix where we match on 
\begin_inset Quotes eld
\end_inset

head
\begin_inset Quotes erd
\end_inset

 value of 1 and then tail of n.
\end_layout

\begin_layout Standard
But there's more (this is one of the favored constructs in the language after all):
 
\end_layout

\begin_layout LyX-Code
val score = 95
\end_layout

\begin_layout LyX-Code
score 
\series bold
match
\end_layout

\begin_layout LyX-Code
  
\series bold
case
\series default
 s 
\emph on
if
\emph default
 s >= 90 
\series bold
=>
\series default
 "A Grade"
\end_layout

\begin_layout LyX-Code
  
\series bold
case
\series default
 s 
\emph on
if
\emph default
 s >= 80 
\series bold
=>
\series default
 "B Grade"
\end_layout

\begin_layout LyX-Code
  
\series bold
case
\series default
 _            
\series bold
=>
\series default
 "Keep trying!"
\end_layout

\begin_layout Standard
In the case conditions,
 we can add 
\begin_inset Quotes eld
\end_inset

if conditions
\begin_inset Quotes erd
\end_inset

.
 So not only can we match on class type and their attribute values,
 but of course we can match on raw values themselves.
 In the example above,
 we check if the score is in a 
\begin_inset Quotes eld
\end_inset

range
\begin_inset Quotes erd
\end_inset

 in the first 2 clauses:
 in the first,
 if it's above 90,
 then the first case action block gets evaluated,
 in the second,
 if it's above 80 (but below 90 since the first case failed),
 the second action block gets evaluated.
 
\end_layout

\begin_layout Standard
So a good way to think of this is the case expressions provide a table of contents to the possible actions that can be taken.
 It's not a simple 
\begin_inset Quotes eld
\end_inset

glorified if statement
\begin_inset Quotes erd
\end_inset

 anymore.
\end_layout

\begin_layout Subsection*
Loops
\end_layout

\begin_layout Standard
When I first started looking back into functional languages,
 one thing I noticed was actually a distinct *lack* of explicit loops.
 This alwasy used to blow my procedural,
 OO mind.
 But as it turns out,
 it reflects a diffeent approach to problem solving altogether.
\end_layout

\begin_layout LyX-Code
val apps = List("sttp",
 "Doobie",
 "Tapir")
\end_layout

\begin_layout LyX-Code

\series bold
for
\series default
 app 
\series bold
<-
\series default
 apps 
\series bold
do
\end_layout

\begin_layout LyX-Code
  println(s"Learning $app...")
\end_layout

\begin_layout Standard
This is a 
\begin_inset Quotes eld
\end_inset

foreach
\begin_inset Quotes erd
\end_inset

 loop in scala.
 Syntax is a little tighter,
 but at a glance you can see the structure clearly.
 We declare an iteration variable,
 
\begin_inset Quotes eld
\end_inset

app
\begin_inset Quotes erd
\end_inset

,
 that gets assigned to each element of the list successively and then the following code block is executed for each instance.
\end_layout

\begin_layout Standard
This is used when the code block has *side effects* – like interactions with I/O,
 database transactions,
 file system calls,
 etc
\end_layout

\begin_layout Standard
While loops are also available when needed:
\end_layout

\begin_layout LyX-Code
var i = 0
\end_layout

\begin_layout LyX-Code
while i < 3 do
\end_layout

\begin_layout LyX-Code
  println(i)
\end_layout

\begin_layout LyX-Code
  i += 1
\end_layout

\begin_layout Standard
But in scala,
 
\begin_inset Quotes eld
\end_inset

side effects
\begin_inset Quotes erd
\end_inset

 that occur with other logic is very much frowned upon.
 It's a mind shift,
 but it turns out it's one that translates quite well even when dealing with large quantities of data.
\end_layout

\begin_layout Subsubsection*
Functional Loops
\end_layout

\begin_layout Standard
So in scala,
 we rarely want to just loop.
 Usually,
 this is called in the context of taking a list of things and transforming it into another list (can be single element) of things.
\end_layout

\begin_layout Standard
A trivial example is as follows:
\end_layout

\begin_layout LyX-Code
val numbers = List(1,
 2,
 3)
\end_layout

\begin_layout LyX-Code
val doubled = numbers.map(n => n * 2) 
\end_layout

\begin_layout LyX-Code
// Result:
 List(2,
 4,
 6)
\end_layout

\begin_layout Standard
Less 
\begin_inset Quotes eld
\end_inset

doing
\begin_inset Quotes erd
\end_inset

.
 More 
\begin_inset Quotes eld
\end_inset

evolving
\begin_inset Quotes erd
\end_inset

 into something new.
\end_layout

\begin_layout Standard
We can add a 
\begin_inset Quotes eld
\end_inset

yield
\begin_inset Quotes erd
\end_inset

 statement too and turn this into factory that produces objects based on conditions (eg.
 filters):
\end_layout

\begin_layout LyX-Code
val names = List("alice",
 "bob",
 "charlie")
\end_layout

\begin_layout LyX-Code
val capitalized = for 
\end_layout

\begin_layout LyX-Code
  name <- names
\end_layout

\begin_layout LyX-Code
  if name.startsWith("a") // Remember our "Guard" from earlier?
\end_layout

\begin_layout LyX-Code
yield 
\end_layout

\begin_layout LyX-Code
  name.capitalize
\end_layout

\begin_layout LyX-Code
// Result:
 List("Alice")
\end_layout

\begin_layout Standard
There are actually a couple of things to note here:
\end_layout

\begin_layout Standard
- the line after the 
\begin_inset Quotes eld
\end_inset

for
\begin_inset Quotes erd
\end_inset

 keyword is called a 
\series bold
generator:

\series default
 it dictates the iterator variable that each element of the collection gets assigned to.
 
\end_layout

\begin_layout Standard
- the line prior to the 
\begin_inset Quotes eld
\end_inset

yield
\begin_inset Quotes erd
\end_inset

 is called a 
\series bold
guard
\series default
:
 it's the condition under which the yield gets invoked (otherwise continuing to the next loop iteration,
 not returning anything)
\end_layout

\begin_layout Standard
- the yield keyword says 
\begin_inset Quotes eld
\end_inset

return the result in this case
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard
- the value after the yield dictates what the actual result is that should be returned
\end_layout

\begin_layout Standard
It may help to know that scala was very much designed from a mathematical background,
 valuing symmetry and comprehensive logic over traditional programming idioms.
\end_layout

\begin_layout Section
Exceptions,
 Catch & Throw
\end_layout

\begin_layout Standard
We all know things go wrong.
 On a semi-regular basis.
 However,
 scala is a language that assumes you know what you're doing.
 Honestly,
 it's like most other languages in this regard.
\end_layout

\begin_layout Standard
To be clear,
 scala does have try catch blocks:
\end_layout

\begin_layout LyX-Code
try {
\end_layout

\begin_layout LyX-Code
  // Some risky Doobie database call
\end_layout

\begin_layout LyX-Code
} catch {
\end_layout

\begin_layout LyX-Code
  case ex:
 java.sql.SQLException if ex.getErrorCode == 101 => 
\end_layout

\begin_layout LyX-Code
    println("Specific DB Error")
\end_layout

\begin_layout LyX-Code
  case ex:
 Exception => 
\end_layout

\begin_layout LyX-Code
    println("Generic Error")
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
As you can see,
 it brings the same robust matching abilities found in match statements.
 Beautiful.
\end_layout

\begin_layout Standard
We can also raise exceptions in the traditional way when need be:
\end_layout

\begin_layout LyX-Code
def getUser(id:
 Int):
 String =
\end_layout

\begin_layout LyX-Code
  if id < 0 then 
\end_layout

\begin_layout LyX-Code
    throw new IllegalArgumentException("IDs cannot be negative!")
\end_layout

\begin_layout LyX-Code
  else 
\end_layout

\begin_layout LyX-Code
    "Alice"
\end_layout

\begin_layout Standard
And of course we can define custom exceptions as well:
\end_layout

\begin_layout LyX-Code
case class DatabaseException(message:
 String,
 code:
 Int) extends Exception(message)
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

// Raising it:
\end_layout

\begin_layout LyX-Code
throw DatabaseException("Connection Timeout",
 504)
\end_layout

\begin_layout Standard
However,
 this is a rarity.
 Typically in scala we make use of 
\series bold
Try
\series default
 
\emph on
containers
\emph default
.
 They wrap computations and return either 
\series bold
Succes(value)
\series default
 or
\series bold
 Failure(exception)
\series default
.
 Here's an example:
\end_layout

\begin_layout LyX-Code

\emph on
import
\emph default
 scala.util.{
\series bold
Try,
 Success,
 Failure
\series default
}
\end_layout

\begin_layout LyX-Code

\emph on
val
\emph default
 result:
 
\series bold
Try
\series default
[Int] = 
\series bold
Try
\series default
("123".toInt)
\end_layout

\begin_layout LyX-Code
result 
\emph on
match
\end_layout

\begin_layout LyX-Code
  
\emph on
case
\emph default
 
\series bold
Success
\series default
(num) 
\emph on
=>
\emph default
 println(s"Got the number:
 $num")
\end_layout

\begin_layout LyX-Code
  
\emph on
case
\emph default
 
\series bold
Failure
\series default
(ex)  
\emph on
=>
\emph default
 println(s"It wasn't a number:
 ${ex.getMessage}")
\end_layout

\begin_layout Standard
We wrap the contentious code in our Try(...) container,
 and then match on the result.
 The match can either be a 
\series bold
Success
\series default
 container with a value (that we get with deconstruction – Success(
\series bold
num
\series default
)),
 or a 
\series bold
Failure
\series default
 container with an exception (which we also get with deconstruction).
\end_layout

\begin_layout Standard
Note:
 another common pattern for dealing with exceptions is via the 
\series bold
Either
\series default
 container.
 
\end_layout

\begin_layout Standard
Either objects have a left and a right result.
 The idiom for errors is often to return Left(
\begin_inset Quotes eld
\end_inset

our error message
\begin_inset Quotes erd
\end_inset

) to raise an exception or Right(result_value) to return successful result:
\end_layout

\begin_layout LyX-Code
def divide(a:
 Int,
 b:
 Int):
 Either[String,
 Int] =
\end_layout

\begin_layout LyX-Code
  if b == 0 then Left("Cannot divide by zero!")
\end_layout

\begin_layout LyX-Code
  else Right(a / b)
\end_layout

\begin_layout LyX-Code
val outcome = divide(10,
 0) // Left("Cannot divide by zero!")
\end_layout

\begin_layout Standard
An additional note on system exceptions.
 Scala doesn't catch errors like 
\begin_inset Quotes eld
\end_inset

Out of Memory
\begin_inset Quotes erd
\end_inset

,
 since if that's broken it's assumed the app will stop working regardless.
\end_layout

\begin_layout Standard
However,
 there is a NonFatal class we can match on that catches any intermediate errors,
 such as file access violations:
\end_layout

\begin_layout LyX-Code
import scala.util.control.NonFatal
\end_layout

\begin_layout LyX-Code
try {
\end_layout

\begin_layout LyX-Code
  // Risky IO or System Access
\end_layout

\begin_layout LyX-Code
} catch {
\end_layout

\begin_layout LyX-Code
  case NonFatal(ex) => 
\end_layout

\begin_layout LyX-Code
    // This catches File IO errors,
 but lets OutOfMemory crash the app
\end_layout

\begin_layout LyX-Code
    println(s"Recoverable error:
 $ex")
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Scala,
 due to it's relationship with the jvm,
 can optionally provide a finally block that gets executed regardless of whether an exception occurred or not,
 to allow for cleanup items such as file closures:
\end_layout

\begin_layout LyX-Code
val source = scala.io.Source.fromFile("renaissance.txt")
\end_layout

\begin_layout LyX-Code
try 
\end_layout

\begin_layout LyX-Code
  println(source.mkString)
\end_layout

\begin_layout LyX-Code
finally 
\end_layout

\begin_layout LyX-Code
  // This code is GUARANTEED to run,
 even if an exception occurs above
\end_layout

\begin_layout LyX-Code
  source.close()
\end_layout

\begin_layout LyX-Code
  println("Resource closed.")
\end_layout

\begin_layout Section
Traits
\end_layout

\begin_layout Standard
Traits are the last major component of the scala language (as of this writing),
 but also considered a major feature.
\end_layout

\begin_layout Standard
In prior versions of scala,
 trait behaved like interfaces – they simply defined what methods that class that was implementing them needed.
\end_layout

\begin_layout Standard
Now,
 however,
 traits have grown into more than that.
 They now provide the same benefits as mixins in Ruby.
 Let's look at an example:
\end_layout

\begin_layout LyX-Code
trait Logger:
\end_layout

\begin_layout LyX-Code
  def log(msg:
 String):
 Unit                 // Abstract:
 No body
\end_layout

\begin_layout LyX-Code
  def info(msg:
 String) = log(s"[INFO] $msg") // Concrete:
 Has a body
\end_layout

\begin_layout Standard
So we can see here that the log method only has a return type ( :
 Unit),
 but no body.
 This is abstract and simply defines what must be defined on the class.
\end_layout

\begin_layout Standard
The info method,
 however,
 is a full implementation in and of itself – as you can tell by the body following 
\begin_inset Quotes eld
\end_inset

=
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Traits are then 
\begin_inset Quotes eld
\end_inset

mixed in
\begin_inset Quotes erd
\end_inset

 to classes using the 
\series bold
extends
\series default
 clause:
\end_layout

\begin_layout LyX-Code
class GenericService extends Logger:
\end_layout

\begin_layout LyX-Code
  def log(msg:
 String) = println(msg)
\end_layout

\begin_layout Standard
Note that return result of 
\begin_inset Quotes eld
\end_inset

Unit
\begin_inset Quotes erd
\end_inset

 is the default for methods that don't mention an explicit return type.
 In the trait definition we *need* this hower,
 in order to denote that there is no body
\end_layout

\begin_layout Standard
We can see that the log method defined in Logger is fully defined in the class that extends it.
\end_layout

\begin_layout Standard
A more robust example:
\end_layout

\begin_layout LyX-Code
trait DatabaseConfig(val dbName:
 String)
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
class DoobieRepository(name:
 String) extends DatabaseConfig(name):
\end_layout

\begin_layout LyX-Code
  def connect() = println(s"Connecting to $dbName")
\end_layout

\begin_layout Standard
Notice here that the trait takes a parameter,
 which then is required by the class and mentioned in the extends clause.
 This allows the trait to make explicit assumptions about attributes available to its methods.
\end_layout

\begin_layout Subsubsection*
Instance Variables in Traits
\end_layout

\begin_layout Standard
Traits can define members they expect to see in the classes that implement them (and even populate them by default):
\end_layout

\begin_layout LyX-Code
trait TaskOptimizer:
\end_layout

\begin_layout LyX-Code
  // The trait expects this to exist
\end_layout

\begin_layout LyX-Code
  def priority:
 Int 
\end_layout

\begin_layout LyX-Code
  def computeSchedule() = 
\end_layout

\begin_layout LyX-Code
    if priority > 10 then "Run Now" else "Wait"
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
class DatabaseTask(val priority:
 Int) extends TaskOptimizer
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
val job = DatabaseTask(priority = 15)
\end_layout

\begin_layout LyX-Code
println(job.computeSchedule()) // "Run Now"
\end_layout

\begin_layout Standard
Note that in the trait we define the trait in much the same way as a method - minus the parenthes.
\end_layout

\begin_layout Standard
Traits can also override the state from the class they inherit from:
\end_layout

\begin_layout LyX-Code
trait VerboseService extends WebService:
\end_layout

\begin_layout LyX-Code
  override val apiKey = "VERBOSE_" + super.apiKey
\end_layout

\begin_layout Subsubsection*
Self-Types in Traits
\end_layout

\begin_layout Standard
We can also define a 
\begin_inset Quotes eld
\end_inset

self
\begin_inset Quotes erd
\end_inset

 in a trait,
 which forces any class extending it to only be of the given type:
\end_layout

\begin_layout LyX-Code
class WebService:
\end_layout

\begin_layout LyX-Code
  val apiKey = "SECRET_123"
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
trait MetricCollector:
\end_layout

\begin_layout LyX-Code
  // This trait can only be mixed into a WebService (or its subclasses)
\end_layout

\begin_layout LyX-Code
  self:
 WebService => 
\end_layout

\begin_layout LyX-Code
  
\end_layout

\begin_layout LyX-Code
  def logUsage() = 
\end_layout

\begin_layout LyX-Code
    // It has access to WebService's state!
\end_layout

\begin_layout LyX-Code
    println(s"Sending metrics for API Key:
 $apiKey")
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
class ProductionService extends WebService,
 MetricCollector
\end_layout

\begin_layout Subsection*
Sealed Traits
\end_layout

\begin_layout Standard
Marking a trait as sealed forces all implementations to reside in the same file.
 The is a commonly enforced idiom in scala.
\end_layout

\begin_layout Subsection*
Including Other Code
\end_layout

\begin_layout Standard
Importing code in scala is based on the concept of packages.
 In source files,
 we can state that any classes declared in the file belong to a specific package name.
\end_layout

\begin_layout LyX-Code
package io.startup.renaissance
\end_layout

\begin_layout LyX-Code
case class User(name:
 String)
\end_layout

\begin_layout Standard
Wherever we want to use this class,
 we can then *import* the package by name:
\end_layout

\begin_layout LyX-Code
import io.startup.renaissance.User
\end_layout

\begin_layout LyX-Code
val u = User("Alice")
\end_layout

\begin_layout Standard
Pretty straightforward.
 But because it's scala,
 we can use this in many flexible ways so save on typing:
\end_layout

\begin_layout LyX-Code
import scala.util.control.*                                   // * imports every package in this domain
\end_layout

\begin_layout LyX-Code
import java.util.{Date => JDate}                              // allows renaming of domain to clean up any naming conflicts
\end_layout

\begin_layout LyX-Code
import sttp.client3.{HttpURLConnectionBackend,
 basicRequest}  // only import the given classes / objects / whatever from the domain
\end_layout

\begin_layout Section
Basic IO
\end_layout

\begin_layout Standard
As in most things,
 scala can do things the basic way.
\end_layout

\begin_layout Standard
Reading from a file:
\end_layout

\begin_layout LyX-Code
import scala.io.Source
\end_layout

\begin_layout LyX-Code
// The "Using" block ensures the file is closed automatically
\end_layout

\begin_layout LyX-Code
val content = Source.fromFile("config.txt").use { source =>
\end_layout

\begin_layout LyX-Code
  source.getLines().toList
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
Writing to a file:
\end_layout

\begin_layout LyX-Code
import java.nio.file.{Files,
 Paths}
\end_layout

\begin_layout LyX-Code
import java.nio.charset.StandardCharsets
\end_layout

\begin_layout LyX-Code
val data = "Hello,
 Scala 3!"
\end_layout

\begin_layout LyX-Code
Files.write(Paths.get("output.txt"),
 data.getBytes(StandardCharsets.UTF_8))
\end_layout

\begin_layout Section
Threads & Processes
\end_layout

\begin_layout Standard
Because it rests on the JVM,
 scala *does* let us run code in threads:
\end_layout

\begin_layout LyX-Code
val thread = new Thread(new Runnable {
\end_layout

\begin_layout LyX-Code
  def run() = println("Running on a raw thread...")
\end_layout

\begin_layout LyX-Code
})
\end_layout

\begin_layout LyX-Code
thread.start()
\end_layout

\begin_layout Standard
However,
 scala favors 
\series bold
futures
\series default
,
 shown in the following approach:
\end_layout

\begin_layout LyX-Code
import scala.concurrent.Future
\end_layout

\begin_layout LyX-Code
import scala.concurrent.ExecutionContext.Implicits.global // The thread pool
\end_layout

\begin_layout LyX-Code
val eventualData = Future {
\end_layout

\begin_layout LyX-Code
  // This runs on a different thread
\end_layout

\begin_layout LyX-Code
  Thread.sleep(1000)
\end_layout

\begin_layout LyX-Code
  "Database result"
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
eventualData.onComplete {
\end_layout

\begin_layout LyX-Code
  case Success(value) => println(s"Got it:
 $value")
\end_layout

\begin_layout LyX-Code
  case Failure(e)     => println(s"Failed:
 $e")
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
A future is a placeholder for a value that does not exist yet.
 Futures pull threads from a Thread Pool (ExecutionContext) and run their cod accordingly.
\end_layout

\begin_layout Standard
We define the future,
 and attach a code block to the onComplete event to deal with the values once they return.
\end_layout

\begin_layout Standard
As we can see,
 the preferred method is not to wait for the result.
 Futures are *eager*,
 so as soon as we define them the begin execution.
 If we want to wait for the result in order to do another calculation,
 we can use the 
\series bold
Await
\series default
 clause:
\end_layout

\begin_layout LyX-Code
import scala.concurrent.Await
\end_layout

\begin_layout LyX-Code
import scala.concurrent.duration.*
\end_layout

\begin_layout LyX-Code
// This pauses the current thread for up to 5 seconds
\end_layout

\begin_layout LyX-Code
val result = Await.result(eventualData,
 5.seconds)
\end_layout

\begin_layout LyX-Code
println(s"I waited,
 and I got:
 $result")
\end_layout

\begin_layout Standard
For cases where we have 2 futures,
 you can use a for statement:
\end_layout

\begin_layout LyX-Code
val result = for
\end_layout

\begin_layout LyX-Code
  user     <- fetchUserFromApi(id)    // Future 1
\end_layout

\begin_layout LyX-Code
  dbStatus <- saveToDatabase(user)    // Future 2
\end_layout

\begin_layout LyX-Code
yield
\end_layout

\begin_layout LyX-Code
  s"Successfully saved ${user.name}"
\end_layout

\begin_layout Standard
For system tasks (that could be run in a console),
 we can use the following syntax:
\end_layout

\begin_layout LyX-Code
import sys.process.*
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
// Simple execution
\end_layout

\begin_layout LyX-Code
"ls -al".!
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
// Capture the output as a String
\end_layout

\begin_layout LyX-Code
val output = "curl https://api.ipify.org".!!
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
// Pipelining commands (just like bash!)
\end_layout

\begin_layout LyX-Code
val result = ("cat names.txt" #| "grep Alice" #| "wc -l").!!
\end_layout

\begin_layout Standard
The simple 
\series bold
.!

\series default
 and 
\series bold
.!!

\series default
 methods on strings make this succinct and powerful.
\end_layout

\begin_layout Section
Testing
\end_layout

\begin_layout Standard
ScalaTest is the most common way to do testing in scala.
 AnyWordSpec in particular is one of the most popular styles:
\end_layout

\begin_layout LyX-Code
import org.scalatest.wordspec.AnyWordSpec
\end_layout

\begin_layout LyX-Code
import org.scalatest.matchers.should.Matchers
\end_layout

\begin_layout LyX-Code
class ProductServiceSpec extends AnyWordSpec with Matchers:
\end_layout

\begin_layout LyX-Code
  "A ProductService" should {
\end_layout

\begin_layout LyX-Code
    "calculate tax correctly" in {
\end_layout

\begin_layout LyX-Code
      val price = 100.0
\end_layout

\begin_layout LyX-Code
      val tax = PriceCalculator.calculateTax(price)
\end_layout

\begin_layout LyX-Code
      tax shouldBe 113.0 // DSL for assertions
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
    "return an error for negative prices" in {
\end_layout

\begin_layout LyX-Code
      val result = PriceCalculator.calculateTax(-1)
\end_layout

\begin_layout LyX-Code
      result shouldBe a [Left[_,
 _]]
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout Standard
We can see even though this is considered a unit test,
 tests are organized around expected behaviour.
 
\begin_inset Quotes eld
\end_inset

shouldBe
\begin_inset Quotes erd
\end_inset

 in particular allows for multiple aspects of testing,
 from specific values to general 
\begin_inset Quotes eld
\end_inset

shape
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Future testing is also a first class citizen.
 ScalaFutures allows this without having to inject 
\begin_inset Quotes eld
\end_inset

wait
\begin_inset Quotes erd
\end_inset

,
 
\begin_inset Quotes eld
\end_inset

sleep
\begin_inset Quotes erd
\end_inset

 or other gross hacks.
\end_layout

\begin_layout LyX-Code
import org.scalatest.concurrent.ScalaFutures
\end_layout

\begin_layout LyX-Code
class ApiSpec extends AnyWordSpec with ScalaFutures:
\end_layout

\begin_layout LyX-Code
  "The API" should {
\end_layout

\begin_layout LyX-Code
    "fetch data eventually" in {
\end_layout

\begin_layout LyX-Code
      val eventualData = mySttpClient.getData() // invokes the future
\end_layout

\begin_layout LyX-Code
      
\end_layout

\begin_layout LyX-Code
      // 'whenReady' waits for the Future to finish
\end_layout

\begin_layout LyX-Code
      whenReady(eventualData) { data =>
\end_layout

\begin_layout LyX-Code
        data.name shouldBe "Renaissance"
\end_layout

\begin_layout LyX-Code
      }
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\begin_layout Standard
When it comes to testing apis and back end SQL stores,
 
\series bold
sttp
\series default
 & 
\series bold
Doobie
\series default
 will be your best friends.
\end_layout

\begin_layout Standard
For property-based testing,
 often the best strategy is to allow some degree of randomness over a reasonably large sample size to ensure spooky behaviours are accounbed for:
\end_layout

\begin_layout LyX-Code
import org.scalatest.concurrent.ScalaFutures
\end_layout

\begin_layout LyX-Code
class ApiSpec extends AnyWordSpec with ScalaFutures:
\end_layout

\begin_layout LyX-Code
  "The API" should {
\end_layout

\begin_layout LyX-Code
    "fetch data eventually" in {
\end_layout

\begin_layout LyX-Code
      val eventualData = mySttpClient.getData()
\end_layout

\begin_layout LyX-Code
      
\end_layout

\begin_layout LyX-Code
      // 'whenReady' waits for the Future to finish
\end_layout

\begin_layout LyX-Code
      whenReady(eventualData) { data =>
\end_layout

\begin_layout LyX-Code
        data.name shouldBe "Renaissance"
\end_layout

\begin_layout LyX-Code
      }
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout LyX-Code
  }
\end_layout

\end_body
\end_document
