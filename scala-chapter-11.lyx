#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass article
\use_default_options true
\maintain_unincluded_children no
\language american
\language_package default
\inputencoding utf8
\fontencoding auto
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement class
\float_alignment class
\paperfontsize default
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_formatted_ref 0
\use_minted 0
\use_lineno 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tablestyle default
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content true
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Standard
Because it rests on the JVM,
 scala *does* let us run code in threads:
\end_layout

\begin_layout LyX-Code
val thread = new Thread(new Runnable {
\end_layout

\begin_layout LyX-Code
  def run() = println("Running on a raw thread...")
\end_layout

\begin_layout LyX-Code
})
\end_layout

\begin_layout LyX-Code
thread.start()
\end_layout

\begin_layout Standard
However,
 scala favors 
\series bold
futures
\series default
,
 shown in the following approach:
\end_layout

\begin_layout LyX-Code
import scala.concurrent.Future
\end_layout

\begin_layout LyX-Code
import scala.concurrent.ExecutionContext.Implicits.global // The thread pool
\end_layout

\begin_layout LyX-Code
val eventualData = Future {
\end_layout

\begin_layout LyX-Code
  // This runs on a different thread
\end_layout

\begin_layout LyX-Code
  Thread.sleep(1000)
\end_layout

\begin_layout LyX-Code
  "Database result"
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
eventualData.onComplete {
\end_layout

\begin_layout LyX-Code
  case Success(value) => println(s"Got it:
 $value")
\end_layout

\begin_layout LyX-Code
  case Failure(e)     => println(s"Failed:
 $e")
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
A future is a placeholder for a value that does not exist yet.
 Futures pull threads from a Thread Pool (ExecutionContext) and run their cod accordingly.
\end_layout

\begin_layout Standard
We define the future,
 and attach a code block to the onComplete event to deal with the values once they return.
\end_layout

\begin_layout Standard
As we can see,
 the preferred method is not to wait for the result.
 Futures are *eager*,
 so as soon as we define them the begin execution.
 If we want to wait for the result in order to do another calculation,
 we can use the 
\series bold
Await
\series default
 clause:
\end_layout

\begin_layout LyX-Code
import scala.concurrent.Await
\end_layout

\begin_layout LyX-Code
import scala.concurrent.duration.*
\end_layout

\begin_layout LyX-Code
// This pauses the current thread for up to 5 seconds
\end_layout

\begin_layout LyX-Code
val result = Await.result(eventualData,
 5.seconds)
\end_layout

\begin_layout LyX-Code
println(s"I waited,
 and I got:
 $result")
\end_layout

\begin_layout Standard
For cases where we have 2 futures,
 you can use a for statement:
\end_layout

\begin_layout LyX-Code
val result = for
\end_layout

\begin_layout LyX-Code
  user     <- fetchUserFromApi(id)    // Future 1
\end_layout

\begin_layout LyX-Code
  dbStatus <- saveToDatabase(user)    // Future 2
\end_layout

\begin_layout LyX-Code
yield
\end_layout

\begin_layout LyX-Code
  s"Successfully saved ${user.name}"
\end_layout

\begin_layout Standard
For system tasks (that could be run in a console),
 we can use the following syntax:
\end_layout

\begin_layout LyX-Code
import sys.process.*
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
// Simple execution
\end_layout

\begin_layout LyX-Code
"ls -al".!
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
// Capture the output as a String
\end_layout

\begin_layout LyX-Code
val output = "curl https://api.ipify.org".!!
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
// Pipelining commands (just like bash!)
\end_layout

\begin_layout LyX-Code
val result = ("cat names.txt" #| "grep Alice" #| "wc -l").!!
\end_layout

\begin_layout Standard
The simple 
\series bold
.!

\series default
 and 
\series bold
.!!

\series default
 methods on strings make this succinct and powerful.
\end_layout

\end_body
\end_document
