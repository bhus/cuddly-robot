#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\use_default_options true
\maintain_unincluded_children no
\language american
\language_package default
\inputencoding utf8
\fontencoding auto
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement class
\float_alignment class
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_formatted_ref 0
\use_minted 0
\use_lineno 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tablestyle default
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content true
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Standard
Because Scala lives on the JVM,
 you can manage raw threads manually.
 It looks exactly like the Java you might remember from years ago:
\end_layout

\begin_layout LyX-Code
val thread = new Thread(() => println("Running on a raw thread..."))
\end_layout

\begin_layout LyX-Code
thread.start()
\end_layout

\begin_layout Standard
But manual threading is like trying to manage a busy kitchen by shouting at every individual cook.
 It’s stressful and prone to accidents.
 In modern Scala,
 we don't manage threads;
 we manage 
\series bold
Futures
\series default
.
\end_layout

\begin_layout Subsection*
The Future:
 A Receipt for Your Result
\end_layout

\begin_layout Standard
A 
\emph on
Future
\emph default
 is a placeholder for a value that hasn't arrived yet.
 Think of it like a buzzer at a restaurant:
 you hold the buzzer (the Future),
 and eventually,
 it vibrates when your food (the Result) is ready.
\end_layout

\begin_layout LyX-Code
import scala.concurrent.Future
\end_layout

\begin_layout LyX-Code
import scala.concurrent.ExecutionContext.Implicits.global // The "Kitchen Staff" (Thread Pool)
\end_layout

\begin_layout LyX-Code
import scala.util.{Success,
 Failure}
\end_layout

\begin_layout LyX-Code
val eventualData = Future {
\end_layout

\begin_layout LyX-Code
  // This block runs on a background thread
\end_layout

\begin_layout LyX-Code
  Thread.sleep(1000) 
\end_layout

\begin_layout LyX-Code
  "The secret ingredient"
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout LyX-Code
eventualData.onComplete {
\end_layout

\begin_layout LyX-Code
  case Success(value) => println(s"Order up:
 $value")
\end_layout

\begin_layout LyX-Code
  case Failure(e) => println(s"The kitchen crashed:
 ${e.getMessage}")
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard

\series bold
Two key things to remember:
\end_layout

\begin_layout Itemize

\series bold
ExecutionContext
\series default
:
 This is the "Thread Pool." It’s a group of worker threads waiting to pick up your tasks.
\end_layout

\begin_layout Itemize

\series bold
Eagerness
\series default
:
 Futures are eager.
 The moment you define one,
 it starts running in the background.
\end_layout

\begin_layout Subsection*
Waiting (The "Break Glass" Option)
\end_layout

\begin_layout Standard
Usually,
 we want our code to be "non-blocking," meaning it never stops to wait.
 But sometimes,
 especially in a small script or a console app,
 you just need the result now.
\end_layout

\begin_layout LyX-Code
import scala.concurrent.Await
\end_layout

\begin_layout LyX-Code
import scala.concurrent.duration.*
\end_layout

\begin_layout LyX-Code
// We pause the current thread for up to 5 seconds
\end_layout

\begin_layout LyX-Code
val result = Await.result(eventualData,
 5.seconds)
\end_layout

\begin_layout LyX-Code
println(s"I waited,
 and I got:
 $result")
\end_layout

\begin_layout Subsection*
The "For" Pipeline:
 Stringing Futures Together
\end_layout

\begin_layout Standard
The real magic happens when you have multiple async tasks that depend on each other.
 Instead of "Callback Hell" (nesting onComplete inside onComplete),
 Scala uses the for-comprehension to create a clean,
 readable pipeline.
\end_layout

\begin_layout LyX-Code
val result = for {
\end_layout

\begin_layout LyX-Code
  user <- fetchUserFromApi(id) // Start task 1
\end_layout

\begin_layout LyX-Code
  dbStatus <- saveToDatabase(user) // Once task 1 finishes,
 start task 2
\end_layout

\begin_layout LyX-Code
} yield {
\end_layout

\begin_layout LyX-Code
  s"Successfully saved ${user.name}"
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Subsection*
Talking to the OS:
 The System Shell
\end_layout

\begin_layout Standard
Sometimes the best tool for the job isn't a Scala library,
 but a command that already exists on your machine.
 Scala makes the system shell feel like a native part of the language using the sys.process package.
\end_layout

\begin_layout Standard
By adding a simple !
 or !!
 to a string,
 you can execute it as a shell command:
\end_layout

\begin_layout LyX-Code
import sys.process.*
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
// 1.
 Just run it (prints to console,
 returns the exit code)
\end_layout

\begin_layout LyX-Code
"ls -al".!
 
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
// 2.
 Capture the output (returns a String)
\end_layout

\begin_layout LyX-Code
val myIp = "curl -s https://api.ipify.org".!!
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
// 3.
 The "Bash" Mode:
 Pipelining
\end_layout

\begin_layout LyX-Code
// You can pipe commands together exactly like a shell script
\end_layout

\begin_layout LyX-Code
val userCount = ("cat names.txt" #| "grep Alice" #| "wc -l").!!
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
println(s"Found $userCount instances of Alice.")
\end_layout

\begin_layout Standard
The simple
\emph on
 .!
 
\emph default
and
\emph on
 .!!

\emph default
 methods make Scala an incredible language for writing system scripts that would usually be written in Bash or Python.
\end_layout

\end_body
\end_document
