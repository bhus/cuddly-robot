#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\use_default_options true
\maintain_unincluded_children no
\language american
\language_package default
\inputencoding utf8
\fontencoding auto
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement class
\float_alignment class
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_formatted_ref 0
\use_minted 0
\use_lineno 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tablestyle default
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content true
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Standard
The best way to learn a language is to build small things that showcase big ideas.
 Scala is unique because it doesn’t force you to choose between being an "Object-Oriented" programmer or a "Functional" programmer.
 It assumes you want the best of both worlds.
\end_layout

\begin_layout Subsection*
Scala is Object-Oriented
\end_layout

\begin_layout Standard
In Scala,
 everything is an object.
 We use classes to define the "blueprints" of our data.
\end_layout

\begin_layout Standard
Scala
\end_layout

\begin_layout LyX-Code
class Song(val title:
 String)
\end_layout

\begin_layout LyX-Code
val favorite = Song("Bad Moon Rising")
\end_layout

\begin_layout LyX-Code
println(favorite.title)
\end_layout

\begin_layout Standard
But sometimes,
 you don't need a blueprint;
 you just need a single,
 specific thing.
 For that,
 Scala has the 
\series bold
Object
\series default
 keyword—
creating a "Singleton" in one line.
 No boilerplate,
 no complex patterns.
\end_layout

\begin_layout Standard
Scala
\end_layout

\begin_layout LyX-Code
object Jukebox:
\end_layout

\begin_layout LyX-Code
  val brand = "Vintage 1970"
\end_layout

\begin_layout LyX-Code
  def play(song:
 String) = println(s"The $brand Jukebox plays:
 $song")
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
Jukebox.play("My Song") 
\end_layout

\begin_layout Subsubsection*
Traits:
 The Secret Ingredient
\end_layout

\begin_layout Standard
If you’ve used Ruby,
 you’ll recognize 
\series bold
Traits
\series default
 as the smarter sibling of Mixins.
 They let you "mix in" behavior to a class without the rigid,
 messy hierarchy of traditional inheritance.
\end_layout

\begin_layout Standard
Scala
\end_layout

\begin_layout LyX-Code
trait Speakable:
\end_layout

\begin_layout LyX-Code
  def sayHi() = println("Hi!")
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
class Human extends Speakable
\end_layout

\begin_layout Subsection*
Scala is Functional
\end_layout

\begin_layout Standard
While objects hold our data,
 
\series bold
Functions
\series default
 transform it.
 Scala encourages "chains" of logic where data flows through a pipeline like water through a filter.
\end_layout

\begin_layout Standard
Scala
\end_layout

\begin_layout LyX-Code
val rawUsers = List("boop_ai",
 "sttp_dev",
 "scala_fan",
 "doobie_pro")
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
val result = rawUsers
\end_layout

\begin_layout LyX-Code
  .map(_.replace("_",
 " ")) // 1.
 Transform:
 Swap underscores for spaces
\end_layout

\begin_layout LyX-Code
  .map(_.capitalize) // 2.
 Transform:
 Uppercase the names
\end_layout

\begin_layout LyX-Code
  .filter(_.length > 8) // 3.
 Filter:
 Keep the long ones
\end_layout

\begin_layout LyX-Code
  .sorted // 4.
 Sort:
 Alphabetical order
\end_layout

\begin_layout Standard

\series bold
Two things to notice here:
\end_layout

\begin_layout Standard

\series bold
The Underscore (_)
\series default
:
 This is Scala’s shorthand for "whatever item I’m currently looking at." It keeps your code incredibly lean.
\end_layout

\begin_layout Standard

\series bold
Interpolation
\series default
:
 The s"..." syntax lets you drop variables directly into strings.
\end_layout

\begin_layout Subsection*
Comprehensions:
 The Logic Engine
\end_layout

\begin_layout Standard
While .map and .filter are great for simple chains,
 sometimes you need to combine data from multiple sources.
 This is where the for-comprehension shines.
 It looks like a loop,
 but it’s actually a powerful way to yield new data from existing lists.
\end_layout

\begin_layout Standard
Scala
\end_layout

\begin_layout LyX-Code
val numbers = List(1,
 2,
 3)
\end_layout

\begin_layout LyX-Code
// For every 'n' in numbers,
 yield 'n * 2'
\end_layout

\begin_layout LyX-Code
val doubled = for n <- numbers yield n * 2
\end_layout

\begin_layout LyX-Code
// Result:
 List(2,
 4,
 6)
\end_layout

\begin_layout Standard
The syntax is deliberate:
\end_layout

\begin_layout Itemize
The 
\series bold
for
\series default
 starts the expression.
\end_layout

\begin_layout Itemize
The 
\series bold
n <- numbers
\series default
 (the generator) pulls each value out of the list one by one.
\end_layout

\begin_layout Itemize
The 
\series bold
yield
\series default
 keyword tells Scala:
 "Take the result of this calculation and put it into a brand new list."
\end_layout

\begin_layout Subsection*
The "No-Null" Policy:
 Options
\end_layout

\begin_layout Standard
In most languages,
 null is a landmine.
 You never know when a variable is empty until your program crashes.
 Scala solves this with the Option type.
 An Option is a box:
 it either contains Some(value) or it is None.
\end_layout

\begin_layout Standard
Scala
\end_layout

\begin_layout LyX-Code
val user:
 Option[String] = Some("Albertus")
\end_layout

\begin_layout LyX-Code
val unknown:
 Option[String] = None
\end_layout

\begin_layout LyX-Code
// You are forced to decide what happens if it's empty
\end_layout

\begin_layout LyX-Code
println(user.getOrElse("Guest")) // Prints:
 Albertus
\end_layout

\begin_layout LyX-Code
println(unknown.getOrElse("Guest")) // Prints:
 Guest
\end_layout

\begin_layout Subsection*
Scala is Both:
 The Case Class & Pattern Match
\end_layout

\begin_layout Standard
The "Killer Feature" of Scala is the Case Class.
 It’s a class that comes pre-packaged with everything you need:
 instant instantiation,
 pretty-printing,
 and the ability to be "unpacked" via Pattern Matching.
\end_layout

\begin_layout Standard
Scala
\end_layout

\begin_layout LyX-Code
case class Player(name:
 String,
 age:
 Int)
\end_layout

\begin_layout LyX-Code
val mario = Player("Mario",
 27)
\end_layout

\begin_layout LyX-Code
val luigi = Player("Luigi",
 29)
\end_layout

\begin_layout LyX-Code
// The "Match" is the crown jewel of Scala control flow
\end_layout

\begin_layout LyX-Code
mario.age match
\end_layout

\begin_layout LyX-Code
  case n if n > 25 => println("Veteran status")
\end_layout

\begin_layout LyX-Code
  case _ => println("Rookie")
\end_layout

\begin_layout Subsection*
6.
 Bringing it All Together
\end_layout

\begin_layout Standard
What does a "real" Scala service look like?
 It mixes all these concepts into a clean,
 readable file.
 Here is a small database interaction using Doobie and our favorite "Functional-Light" patterns.
\end_layout

\begin_layout Standard
Scala
\end_layout

\begin_layout LyX-Code
package io.startup.api
\end_layout

\begin_layout LyX-Code
import doobie.*
\end_layout

\begin_layout LyX-Code
import doobie.implicits.*
\end_layout

\begin_layout LyX-Code
import cats.effect.IO
\end_layout

\begin_layout LyX-Code
// 1.
 A Trait for configuration (the "Mixin")
\end_layout

\begin_layout LyX-Code
trait DBConfig:
\end_layout

\begin_layout LyX-Code
  val xa = Transactor.fromDriverManager[IO](
\end_layout

\begin_layout LyX-Code
    "org.postgresql.Driver",
 "jdbc:postgresql:db",
 "user",
 "pass"
\end_layout

\begin_layout LyX-Code
  )
\end_layout

\begin_layout LyX-Code
// 2.
 A Case Class for our data structure
\end_layout

\begin_layout LyX-Code
case class Product(id:
 Int,
 name:
 String)
\end_layout

\begin_layout LyX-Code
// 3.
 An Object to hold our logic
\end_layout

\begin_layout LyX-Code
object ProductService extends DBConfig:
\end_layout

\begin_layout LyX-Code
  def getProduct(id:
 Int) = 
\end_layout

\begin_layout LyX-Code
    sql"select id,
 name from products where id = $id"
\end_layout

\begin_layout LyX-Code
      .query[Product] // Map the SQL columns directly to our Case Class
\end_layout

\begin_layout LyX-Code
      .unique
\end_layout

\begin_layout LyX-Code
      .transact(xa)
\end_layout

\begin_layout Standard
In just a few lines,
 we’ve defined a data model,
 set up a database connection,
 and written a type-safe query that maps SQL directly to a Scala object.
\end_layout

\end_body
\end_document
