#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\use_default_options true
\maintain_unincluded_children no
\language american
\language_package default
\inputencoding utf8
\fontencoding auto
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement class
\float_alignment class
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_formatted_ref 0
\use_minted 0
\use_lineno 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tablestyle default
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content true
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Standard
One of the goals of this book was to bring a de-mystified,
 solid introduction to the reader of the scala language.
 As we have mentioned,
 from a layman,
 outsider view scala is viewed as academic.
 Not the 
\begin_inset Quotes eld
\end_inset

well-organized
\begin_inset Quotes erd
\end_inset

,
 
\begin_inset Quotes eld
\end_inset

well-thought out
\begin_inset Quotes erd
\end_inset

 sense,
 but in the 
\begin_inset Quotes eld
\end_inset

it's very theoretical and inaccessible to non-enlightened folks
\begin_inset Quotes erd
\end_inset

 sense.
 This is tragic,
 and we think can and should be remedied by a prioritized,
 pragmatic,
 
\begin_inset Quotes eld
\end_inset

work with the code first
\begin_inset Quotes erd
\end_inset

 approach.
\end_layout

\begin_layout Standard
So,
 now that we have our environment set up,
 let's build a few small things and take a 
\begin_inset Quotes eld
\end_inset

high level
\begin_inset Quotes erd
\end_inset

 tour of the language.
 We can dissect more rigorously later.
\end_layout

\begin_layout Subsection*
Scala is Object-Oriented
\end_layout

\begin_layout Standard
In Scala,
 everything is an object.
 Variables.
 Values.
 Everything.
 Of course,
 there are a ton of languages that make that claim – let's run through what this means for scala.
\end_layout

\begin_layout Standard
We use classes to define the "blueprints" of data (that aren't already defined as a base class – with some exceptions).
 The classic example is a jukebox,
 where each *song* could be considered a class instance.
 You could store the name of the song,
 and the artist,
 as attributes.
 We could also define methods,
 such as 
\begin_inset Quotes eld
\end_inset

play
\begin_inset Quotes erd
\end_inset

,
 that could be formed by the instance.
 The word object is used interchangeably with class instances.
 
\end_layout

\begin_layout Standard
In scala,
 these objects usually created by calling the special 
\emph on
constructor
\emph default
 for the class,
 which is just the class name followed by parameters in parentheses:
\end_layout

\begin_layout LyX-Code
class Song(val title:
 String)          // define the constructor
\end_layout

\begin_layout LyX-Code
val favorite = Song("Bad Moon Rising") // call the constructor
\end_layout

\begin_layout LyX-Code
println(favorite.title)
\end_layout

\begin_layout Standard
You can see that we define the Song class as taking a String parameter called *title*.
 We then call that constructor with a string value for the title (
\begin_inset Quotes eld
\end_inset

Bad Moon Rising
\begin_inset Quotes erd
\end_inset

).
\end_layout

\begin_layout Standard
We define multiple class instances by calling the constructor with different parameters.
\end_layout

\begin_layout LyX-Code
val favorite = Song(
\begin_inset Quotes eld
\end_inset

Fire It Up
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout LyX-Code
val secondFavorite = Song(
\begin_inset Quotes eld
\end_inset

Smells like Teen Spirit
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard
We add methods to a class with the 
\begin_inset Quotes eld
\end_inset

def
\begin_inset Quotes erd
\end_inset

 keyword (that you may recognize from other languages like Ruby).
\end_layout

\begin_layout LyX-Code
class Book(val title:
 String,
 val author:
 String)
\end_layout

\begin_layout LyX-Code
  def getIndexInfo() =
\end_layout

\begin_layout LyX-Code
    s"Book title:
 $title.
 Written by:
 $author"
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

val book = Book("The Stand",
 "Stephen King")
\end_layout

\begin_layout LyX-Code
println(book.getIndexInfo()) // -> Book title:
 The Stand.
 Written by:
 Stephen King
\end_layout

\begin_layout Standard
Note there's no return call needed – the last value is assumed to be the result.
\end_layout

\begin_layout Standard
Note also the return string is enclosed in 
\series bold
s"...".
 
\series default
This tells us the string contains variable values (prefixed with a $),
 along with other substitutions like newline ( 
\backslash
n ).
\end_layout

\begin_layout Standard
Like we said,
 everything in scala is an object,
 so variables and literals alike can have the methods invoked on them:
\end_layout

\begin_layout LyX-Code
favorite.toUpperCase() // -> FIRE IT UP
\end_layout

\begin_layout LyX-Code
\begin_inset Quotes eld
\end_inset

Dude
\begin_inset Quotes erd
\end_inset

.toLowerCase()   // -> dude
\end_layout

\begin_layout Standard
Here's where it gets a little tricky :
 you can also create *single* objects,
 without requiring a class.
 After all,
 sometimes,
 you don't need a blueprint;
 you just need a single,
 specific thing.
 
\end_layout

\begin_layout Standard
For this,
 Scala has the 
\series bold
Object
\series default
 keyword—
creating a "Singleton" in one line.
 No boilerplate,
 no complex patterns.
\end_layout

\begin_layout LyX-Code
object Jukebox:
  // define the object
\end_layout

\begin_layout LyX-Code
  val brand = "Vintage 1970"
\end_layout

\begin_layout LyX-Code
  def play(song:
 String) = println(s"The $brand Jukebox plays:
 $song")
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
Jukebox.play("My Song") // call the play method on the object
\end_layout

\begin_layout Standard
Now that we have some multiline code,
 we will point out something - notice that,
 after we declare the object,
 all of the code that belongs to it on subsequent lines is indented.
 This is a pattern from other languages like python,
 which allows for cleaner code due to the absence of braces you typically find in C-inspired languages (*cough* java *cough*) – the body of the method does not have braces,
 or even and 
\begin_inset Quotes eld
\end_inset

end
\begin_inset Quotes erd
\end_inset

.
 The body is simply denoted by being indented.
\end_layout

\begin_layout Standard
If you’ve used Ruby,
 you’ll recognize 
\series bold
Traits
\series default
 as the smarter sibling of Mixins.
 They let you "mix in" behavior to a class without the rigid,
 messy hierarchy of traditional inheritance.
\end_layout

\begin_layout Standard
Scala
\end_layout

\begin_layout LyX-Code
trait Speakable:
\end_layout

\begin_layout LyX-Code
  def sayHi() = println("Hi!")
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
class Human extends Speakable
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

val baby = Human()
\end_layout

\begin_layout LyX-Code
vaby.sayHi()
\end_layout

\begin_layout Standard
In practice,
 what this means is that we can add behaviour to classes without a mess of complex hierarchies.
 Want a function from a class?
 Just add it in – no need to think about which relative to add it to.
 Traits can also define & contain state – but we will talk about that later.
\end_layout

\begin_layout Subsection*
Scala is Functional
\end_layout

\begin_layout Standard
While objects hold our data,
 
\series bold
Functions
\series default
 transform it.
 Where other languages shy away,
 scala full embraces this duality of object orientedness and functional focus.
\end_layout

\begin_layout Standard
Scala encourages "chains" of logic where data flows through a pipeline like water through a filter.
\end_layout

\begin_layout LyX-Code
val rawUsers = List("boop_ai",
 "sttp_dev",
 "scala_fan",
 "doobie_pro")
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
val result = rawUsers
\end_layout

\begin_layout LyX-Code
  .map(_.replace("_",
 " ")) // 1.
 Transform:
 Swap underscores for spaces
\end_layout

\begin_layout LyX-Code
  .map(_.capitalize) // 2.
 Transform:
 Uppercase the names
\end_layout

\begin_layout LyX-Code
  .filter(_.length > 8) // 3.
 Filter:
 Keep the long ones
\end_layout

\begin_layout LyX-Code
  .sorted // 4.
 Sort:
 Alphabetical order
\end_layout

\begin_layout Standard
The Underscore (_) is Scala’s shorthand for "whatever item I’m currently looking at." It keeps your code incredibly lean.
\end_layout

\begin_layout Subsection*
Scala is a Duality
\end_layout

\begin_layout Standard
Case classes are a special class that comes pre-packaged with everything you need:
 instant instantiation,
 pretty-printing.
\end_layout

\begin_layout Standard
In particular,
 case class variables can be easily "unpacked":
\end_layout

\begin_layout LyX-Code
case class Player(name:
 String,
 age:
 Int)
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
val mario = Player("Mario",
 27)
\end_layout

\begin_layout LyX-Code
\begin_inset Newline newline
\end_inset

val User(m_name,
 m_age) = mario    // -> we get m_name = 
\begin_inset Quotes eld
\end_inset

Mario
\begin_inset Quotes erd
\end_inset

,
 m_age = 27
\end_layout

\begin_layout Standard
We can see that we cleanly now get values from inside the object assigned to variables.
\end_layout

\begin_layout Subsection*
Some Basic Scala
\end_layout

\begin_layout Standard
So what does this all mean?
 What does a "real" Scala service look like?
 It mixes these concepts into a clean,
 readable file.
 Here is a small database interaction using Doobie and our favorite "Functional-Light" patterns.
\end_layout

\begin_layout LyX-Code
package io.startup.api
\end_layout

\begin_layout LyX-Code
import doobie.*
\end_layout

\begin_layout LyX-Code
import doobie.implicits.*
\end_layout

\begin_layout LyX-Code
import cats.effect.IO
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
// 1.
 A Trait for configuration (the "Mixin")
\end_layout

\begin_layout LyX-Code
trait DBConfig:
\end_layout

\begin_layout LyX-Code
  val xa = Transactor.fromDriverManager[IO](
\end_layout

\begin_layout LyX-Code
    "org.postgresql.Driver",
 "jdbc:postgresql:db",
 "user",
 "pass"
\end_layout

\begin_layout LyX-Code
  )
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
// 2.
 A Case Class for our data structure
\end_layout

\begin_layout LyX-Code
case class Product(id:
 Int,
 name:
 String)
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
// 3.
 An Object to hold our logic
\end_layout

\begin_layout LyX-Code
object ProductService extends DBConfig:
 // Mixes in DBConfig trait from above
\end_layout

\begin_layout LyX-Code
  def getProduct(id:
 Int) = 
\end_layout

\begin_layout LyX-Code
    sql"select id,
 name from products where id = $id"
\end_layout

\begin_layout LyX-Code
      .query[Product]                   // Map the SQL columns directly to our Case Class
\end_layout

\begin_layout LyX-Code
      .unique
\end_layout

\begin_layout LyX-Code
      .transact(xa)                     // Chain methods to get everything we need
\end_layout

\begin_layout Standard
In just a few lines,
 we’ve defined a data model,
 set up a database connection,
 and written a type-safe query that maps SQL directly to a Scala object.
\end_layout

\begin_layout Subsection*
Pattern Matching
\end_layout

\begin_layout Standard
At a first glance,
 matching in scala looks much the same:
 take a variable,
 define a match,
 then add cases and how to handle them.
\end_layout

\begin_layout Standard
However,
 Pattern Matching
\series bold
 is what many consider a defining feature of scala.

\series default
 And that's because it's a lot more robust that in other languages.
 
\end_layout

\begin_layout Standard
One particular strength of scala is the ability to combine "unpacking" with Pattern Matching:
\end_layout

\begin_layout LyX-Code
mario match {
\end_layout

\begin_layout LyX-Code
  case User(name,
 age) => s"$name is $age years old."
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
We get the ability to make decisions based on attributes *inside* the object.
 This can be used recursively to pull apart members of objects that are themselves objects.
\end_layout

\begin_layout Standard
Matches go much further,
 however,
 enabling condition checks in each case,
 unpacking of list elements,
 and more.
\end_layout

\begin_layout LyX-Code
user match {
\end_layout

\begin_layout LyX-Code
  case User("Alice",
 _) => "Found the boss!"
\end_layout

\begin_layout LyX-Code
  case User(name,
 age) if age < 18 => s"$name is a minor."
\end_layout

\begin_layout LyX-Code
  case User(name,
 _) => s"Regular user:
 $name"
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
\begin_inset Separator plain
\end_inset


\end_layout

\begin_layout LyX-Code
val numbers = List(1,
 2,
 3,
 4)
\end_layout

\begin_layout LyX-Code
numbers match {
\end_layout

\begin_layout LyX-Code
  case head ::
 second ::
 tail => s"Starts with $head and $second,
 then the rest:
 $tail"
\end_layout

\begin_layout LyX-Code
  case head ::
 Nil            => s"Only one element:
 $head"
\end_layout

\begin_layout LyX-Code
  case Nil                    => "The list is empty"
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Standard
We can see here how much scala depends on classes.
 Moreso than other languages,
 they are a central element of the language,
 using class equivalence as major decision-making mechanisms.
\end_layout

\begin_layout Subsection*
A Mathematical Heritage
\end_layout

\begin_layout Standard
There's no getting around it - Scala evolved from a very mathematical worldview.
 Treating code as a language that encapsulates a comprehensive view of the world can lead to some innovative approaches.
 
\end_layout

\begin_layout Subsubsection*
The "No-Null" Policy:
 Options
\end_layout

\begin_layout Standard
In most languages,
 null/nil is a landmine.
 You never know when a variable is empty until your program crashes.
 
\end_layout

\begin_layout Standard
Scala solves this with the Option type.
 An Option is a box:
 it either contains Some(value) or it is None.
 This forces any code that deals with the value to explicitly state what happens when it's null.
\end_layout

\begin_layout LyX-Code
val user:
 Option[String] = Some("Albertus")
\end_layout

\begin_layout LyX-Code
val unknown:
 Option[String] = None
\end_layout

\begin_layout LyX-Code
// You are forced to decide what happens if it's empty
\end_layout

\begin_layout LyX-Code
println(user.getOrElse("Guest")) // Prints:
 Albertus
\end_layout

\begin_layout LyX-Code
println(unknown.getOrElse("Guest")) // Prints:
 Guest
\end_layout

\end_body
\end_document
