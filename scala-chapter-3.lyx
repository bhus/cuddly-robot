#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\use_default_options true
\maintain_unincluded_children no
\language american
\language_package default
\inputencoding utf8
\fontencoding auto
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement class
\float_alignment class
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_formatted_ref 0
\use_minted 0
\use_lineno 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tablestyle default
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content true
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Standard
In some circles,
 Scala is praised purely for its Functional Programming (FP) chops.
 But Scala prides itself on being a "unification" of two patterns.
 It doesn't treat Object-Orientation (OO) like a legacy burden;
 it treats it as a first-class way to organize code.
\end_layout

\begin_layout Standard
Let's look at how Scala takes the "boilerplate" out of objects.
\end_layout

\begin_layout Subsection*
The Lean Class
\end_layout

\begin_layout Standard
In many languages,
 creating a simple data class requires a constructor,
 field definitions,
 and assignments.
 In Scala,
 the class header does all three at once.
\end_layout

\begin_layout LyX-Code
class Company(val name:
 String,
 val revenue:
 Int)
\end_layout

\begin_layout LyX-Code
val myCompany = Company("saas-o-rama",
 7000)
\end_layout

\begin_layout LyX-Code
pprint.pprintln(myCompany)
\end_layout

\begin_layout LyX-Code
// Result:
 hello$_$Company@6d8a00e3
\end_layout

\begin_layout Standard
That output—
the "raw dump"—
isn't very helpful.
 In the Pickaxe tradition,
 we want our objects to be communicative.
 Let’s override the default toString to give us a professional readout.
\end_layout

\begin_layout LyX-Code
class Company(val name:
 String,
 val revenue:
 Int):
\end_layout

\begin_layout LyX-Code
  override def toString:
 String = 
\end_layout

\begin_layout LyX-Code
    s"[Company:
 $name | MRR:
 $$$revenue]"
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
val myCompany = Company("saas-o-rama",
 7000)
\end_layout

\begin_layout LyX-Code
pprint.pprintln(myCompany) 
\end_layout

\begin_layout LyX-Code
// Result:
 [Company:
 saas-o-rama | MRR:
 $7000]
\end_layout

\begin_layout Subsection*
Specialized Roles:
 Inheritance
\end_layout

\begin_layout Standard
Inheritance allows us to create specialized versions of a general concept.
 A "Startup," for example,
 is just a Company that (usually) has seed money and a higher burn rate.
\end_layout

\begin_layout LyX-Code
class StartupCompany(name:
 String,
 revenue:
 Int,
 val seedMoney:
 Int) 
\end_layout

\begin_layout LyX-Code
  extends Company(name,
 revenue):
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
  override def toString:
 String =
\end_layout

\begin_layout LyX-Code
    val parentText = super.toString()
\end_layout

\begin_layout LyX-Code
    s"[Startup:
 $name | Seed:
 $$$seedMoney] (Parent Info:
 $parentText)"
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
val myStartup = StartupCompany("startup-o-rama",
 7000,
 80000)
\end_layout

\begin_layout LyX-Code
pprint.pprintln(myStartup)
\end_layout

\begin_layout Standard
Notice that we pass name and revenue up to the "parent" Company.
 We don't mark them as val in the StartupCompany header because they are already defined in the base class.
\end_layout

\begin_layout Subsection*
Mutability:
 The val vs var Choice
\end_layout

\begin_layout Standard
In the class signature,
 you have a choice that defines the "soul" of your object:
\end_layout

\begin_layout Itemize

\series bold
val (Value):

\series default
 Creates a read-only field (a "Getter").
 This is the Scala default for a reason—
immutable data is easier to reason about.
\end_layout

\begin_layout Itemize

\series bold
var (Variable):

\series default
 Creates a field that can be changed (a "Getter" and a "Setter").
\end_layout

\begin_layout LyX-Code
class FlexibleCompany(val name:
 String,
 var revenue:
 Int)
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
val c = FlexibleCompany("Pivot-Co",
 1000)
\end_layout

\begin_layout LyX-Code
c.revenue = 5000 // Perfectly legal because it's a 'var'
\end_layout

\begin_layout LyX-Code
// c.name = "NewName" // This would trigger a compiler error!
\end_layout

\begin_layout Subsection*
Companion Objects:
 The Better "Static"
\end_layout

\begin_layout Standard
In Java or C#,
 you use the static keyword for methods that belong to the class rather than an instance.
 Scala replaces this with the Companion Object.
\end_layout

\begin_layout Standard
If you create an object with the same name as your class in the same file,
 they become "companions." This is where you put your Factory Methods (methods that build instances for you).
\end_layout

\begin_layout LyX-Code
class Company(val name:
 String,
 val revenue:
 Int)
\end_layout

\begin_layout LyX-Code
object Company:
\end_layout

\begin_layout LyX-Code
  // A Factory Method
\end_layout

\begin_layout LyX-Code
  def buildBootstrapped(name:
 String):
 Company =
\end_layout

\begin_layout LyX-Code
    println(s"Building $name with zero outside capital...")
\end_layout

\begin_layout LyX-Code
    new Company(name,
 0)
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
// Usage:
\end_layout

\begin_layout LyX-Code
val myNewCo = Company.buildBootstrapped("Funco")
\end_layout

\begin_layout Standard
When you call Company.buildBootstrapped,
 you are talking to the Object (the singleton).
 When it returns a value,
 it gives you an instance of the Class.
\end_layout

\begin_layout Subsection*
Global State and App Configuration
\end_layout

\begin_layout Standard
Not every object needs a "class" counterpart.
 Sometimes you just need a place to store global settings or utility functions that stay consistent across your entire application.
\end_layout

\begin_layout LyX-Code
Scala
\end_layout

\begin_layout LyX-Code
object AppConfig:
\end_layout

\begin_layout LyX-Code
  val apiBase = "https://api.startup.io"
\end_layout

\begin_layout LyX-Code
  var debugMode = true
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
// Accessible anywhere without using 'new'
\end_layout

\begin_layout LyX-Code
if AppConfig.debugMode then 
\end_layout

\begin_layout LyX-Code
  println(s"Connecting to ${AppConfig.apiBase}")
\end_layout

\begin_layout Standard
This is the ultimate Pragmatic tool:
 it’s clean,
 it’s always there when you need it,
 and it doesn't require complex "Singleton Pattern" boilerplate.
\end_layout

\end_body
\end_document
