#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\use_default_options true
\maintain_unincluded_children no
\language american
\language_package default
\inputencoding utf8
\fontencoding auto
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement class
\float_alignment class
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_formatted_ref 0
\use_minted 0
\use_lineno 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tablestyle default
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content true
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Standard
Scala is more than just a high-level language;
 it’s a language built for performance.
 Because it runs on the JVM,
 it gives you direct control over how your data is stored.
 You don't have to worry about these details every day,
 but when you're processing a billion rows of data,
 you'll be glad Scala doesn't hide the "plumbing."1.
 
\end_layout

\begin_layout Subsection*
Numbers:
 Choosing Your Precision
\end_layout

\begin_layout Standard
In a script,
 a number is just a "number." In Scala,
 we choose the right tool for the job.
 This keeps your code optimized and your memory usage lean.
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="6" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Range / Use Case
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Byte
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
-128 to 127 (Ultra-lean)
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Int
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The standard 32-bit integer.
 Your default choice.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Long
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
64-bit integer.
 Use this for IDs or massive counts.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Double
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
The standard for decimals and scientific math.
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
BigInt
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Numbers as large as your RAM will allow.
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Subsection*
Strings:
 The 200-Method Superpower
\end_layout

\begin_layout Standard
In Scala,
 a String is technically a Java String,
 but it’s been "upgraded." Scala breathes life into strings by adding over 200 methods that make text manipulation feel like magic.
\end_layout

\begin_layout Subsubsection*
Literals and Layouts
\end_layout

\begin_layout Standard
You can define strings with single quotes (for a single Char),
 double quotes,
 or triple quotes for multi-line blocks.
 To keep your code indented without messing up your string's formatting,
 we use the "Pipe and Strip" trick:
\end_layout

\begin_layout LyX-Code
Scala
\end_layout

\begin_layout LyX-Code
val html = """<html>
\end_layout

\begin_layout LyX-Code
| <body>Hello Scala!</body>
\end_layout

\begin_layout LyX-Code
|</html>""".stripMargin
\end_layout

\begin_layout Standard
The | symbol marks the "margin," and .stripMargin trims everything to the left of it.
 It’s a small detail that makes your source code much more readable.
\end_layout

\begin_layout Subsubsection*
Interpolation:
 Mixing Logic and Text
\end_layout

\begin_layout Standard
Why concatenate strings with + when you can bake variables right into them?
\end_layout

\begin_layout Itemize
s interpolation:
 For standard variable injection.
\end_layout

\begin_layout Itemize
f interpolation:
 For "formatted" injection (like rounding decimals).
\end_layout

\begin_layout LyX-Code
Scala
\end_layout

\begin_layout LyX-Code
val name = "Renaissance"
\end_layout

\begin_layout LyX-Code
println(s"Welcome to $name version ${1 + 1}")
\end_layout

\begin_layout LyX-Code
val pi = 3.14159
\end_layout

\begin_layout LyX-Code
println(f"Pi is roughly $pi%.2f") // Result:
 "Pi is roughly 3.14"
\end_layout

\begin_layout Subsubsection*
Ranges:
 Memory-Efficient Sequences
\end_layout

\begin_layout Standard
A Range is a clever abstraction.
 It represents a list of values (like 1 to 1000) without actually creating 1000 integers in your memory.
 It only generates the numbers as you need them.
\end_layout

\begin_layout LyX-Code
Scala
\end_layout

\begin_layout LyX-Code
val alphabet = 'a' to 'z' // Includes 'z'
\end_layout

\begin_layout LyX-Code
val countdown = 10 until 0 by -1 // 10,
 9,
 8...
 1 (Excludes 0)
\end_layout

\begin_layout LyX-Code
val odds = 1 to 10 by 2 // 1,
 3,
 5,
 7,
 9
\end_layout

\begin_layout Standard
If you ever need to "solidify" a range into a real list,
 just call .toList.
\end_layout

\begin_layout Subsubsection*
Regular Expressions:
 Patterns as Objects
\end_layout

\begin_layout Standard
In many languages,
 Regex is a separate "mini-language" that feels bolted on.
 In Scala,
 Regular Expressions are first-class objects created by adding .r to a string.
\end_layout

\begin_layout LyX-Code
Scala
\end_layout

\begin_layout LyX-Code
val EmailRegex = """([a-zA-Z0-9.-]+)@([a-zA-Z0-9.-]+
\backslash
.[a-zA-Z]{2,4})""".r
\end_layout

\begin_layout Standard
Because they are objects,
 you can call methods directly on them:
\end_layout

\begin_layout LyX-Code
Scala
\end_layout

\begin_layout LyX-Code
val text = "We have 10 apples and 20 oranges"
\end_layout

\begin_layout LyX-Code
val NumberRegex = """(
\backslash
d+)""".r
\end_layout

\begin_layout LyX-Code
val first = NumberRegex.findFirstIn(text) // Some("10")
\end_layout

\begin_layout LyX-Code
val all = NumberRegex.findAllIn(text).toList // List("10",
 "20")
\end_layout

\begin_layout Subsubsection*
The Power Play:
 Regex in Pattern Matching
\end_layout

\begin_layout Standard
This is where the "Pickaxe" style of programming really shines.
 You can use your Regex directly inside a match statement to extract data instantly.
\end_layout

\begin_layout LyX-Code
Scala
\end_layout

\begin_layout LyX-Code
val input = "Contact us at support@startup.io"
\end_layout

\begin_layout LyX-Code
input match
\end_layout

\begin_layout LyX-Code
case EmailRegex(user,
 domain) => println(s"User:
 $user on $domain")
\end_layout

\begin_layout LyX-Code
case _ => println("No email found.")
\end_layout

\begin_layout Subsection*
The "Any" Catch-all
\end_layout

\begin_layout Standard
Sometimes you don't know what kind of data you're going to get.
 The Any type is the root of all types in Scala.
 You can use it to create functions that handle anything,
 using pattern matching to sort out the types on the fly.
\end_layout

\begin_layout LyX-Code
Scala
\end_layout

\begin_layout LyX-Code
def process(input:
 Any):
 Unit = input match
\end_layout

\begin_layout LyX-Code
case s:
 String => println(s"Processing text:
 $s")
\end_layout

\begin_layout LyX-Code
case i:
 Int => println(s"Processing number:
 $i")
\end_layout

\begin_layout LyX-Code
case _ => println("Unknown entity detected.")
\end_layout

\end_body
\end_document
