#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\use_default_options true
\maintain_unincluded_children no
\language american
\language_package default
\inputencoding utf8
\fontencoding auto
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement class
\float_alignment class
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_formatted_ref 0
\use_minted 0
\use_lineno 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tablestyle default
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content true
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
section*{Chapter 16:
 Driving the Web}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Scala's web ecosystem is built for scale,
 but modern tools like 
\backslash
texttt{Tapir} and 
\backslash
texttt{sttp} ensure that "scale" doesn't mean "complexity." In this chapter,
 we move beyond scripts and into the world of REST APIs and HTTP services.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
subsection*{The Tapir Philosophy:
 Endpoints as Values}
\end_layout

\begin_layout Plain Layout

In most frameworks,
 an endpoint is a function.
 In Scala,
 an endpoint is a 
\backslash
textbf{value}.
 This means you can describe your API (its inputs,
 outputs,
 and errors) once,
 and then use that description to generate a server,
 a client,
 and documentation.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

import sttp.tapir.*
\end_layout

\begin_layout Plain Layout

import sttp.tapir.json.zio.* // Define the "Shape" of your endpoint
\end_layout

\begin_layout Plain Layout

val helloEndpoint = endpoint.get
\end_layout

\begin_layout Plain Layout

  .in("hello")
\end_layout

\begin_layout Plain Layout

  .in(query[String]("name"))
\end_layout

\begin_layout Plain Layout

  .out(stringBody)
\end_layout

\begin_layout Plain Layout

  .errorOut(stringBody)
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
subsection*{Serving the API}
\end_layout

\begin_layout Plain Layout

Once the shape is defined,
 you simply "bind" logic to it.
 Because we are using 
\backslash
texttt{sttp} for HTTP,
 the transition from definition to execution is seamless.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

val helloLogic = helloEndpoint.serverLogic { name =>
\end_layout

\begin_layout Plain Layout

  if (name.isEmpty) Future.successful(Left("Name cannot be empty"))
\end_layout

\begin_layout Plain Layout

  else Future.successful(Right(s"Hello,
 $name!
 Welcome to Renaissance."))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
subsection*{The JSON Connection}
\end_layout

\begin_layout Plain Layout

Scala excels at Case Class to JSON conversion.
 By using a library like 
\backslash
texttt{ZIO-JSON},
 you can send and receive complex objects without manual parsing.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

case class CompanyStats(name:
 String,
 revenue:
 Int)
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// Tapir handles JSON conversion based on your case class
\end_layout

\begin_layout Plain Layout

val statsEndpoint = endpoint.get
\end_layout

\begin_layout Plain Layout

  .in("stats" / path[String]("orgId"))
\end_layout

\begin_layout Plain Layout

  .out(jsonBody[CompanyStats])
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
subsection*{Connecting the Database:
 Doobie in the Web}
\end_layout

\begin_layout Plain Layout

A web app is only as good as its data.
 Following our project standard,
 we use 
\backslash
textbf{Doobie} to bridge the gap between our endpoints and our SQL store.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

import doobie.*
\end_layout

\begin_layout Plain Layout

import doobie.implicits.*
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

def getStats(orgId:
 String):
 ConnectionIO[CompanyStats] =
\end_layout

\begin_layout Plain Layout

  sql"SELECT name,
 revenue FROM organizations WHERE id = $orgId"
\end_layout

\begin_layout Plain Layout

    .query[CompanyStats]
\end_layout

\begin_layout Plain Layout

    .unique
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

// In your server logic,
 you run the Doobie program:
\end_layout

\begin_layout Plain Layout

val statsLogic = statsEndpoint.serverLogic { id =>
\end_layout

\begin_layout Plain Layout

  getStats(id).transact(xa).map(Right(_))
\end_layout

\begin_layout Plain Layout

}
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
subsection*{Automatic Documentation}
\end_layout

\begin_layout Plain Layout

Because your endpoints are values,
 Scala can look at them and generate an OpenAPI/Swagger UI automatically.
 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

import sttp.tapir.swagger.bundle.SwaggerInterpreter
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

val swaggerEndpoints = SwaggerInterpreter()
\end_layout

\begin_layout Plain Layout

  .fromEndpoints(List(helloEndpoint,
 statsEndpoint),
 "My API",
 "1.0")
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
section*{Chapter 16.5:
 Launching the Server}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

Describing an endpoint is one thing;
 actually listening for traffic on port 8080 is another.
 To stay "Pragmatic," we want a server that is fast,
 lightweight,
 and easy to configure.
 Using the 
\backslash
texttt{NettyFutureServer} interpreter,
 we can turn our Tapir logic into a running process.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
subsection*{The Main Entry Point}
\end_layout

\begin_layout Plain Layout

Following our Scala 3 standards,
 we use the 
\backslash
texttt{@main} annotation to create our server's entry point.
 This script pulls everything together:
 your endpoints,
 your logic,
 and the server engine.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

import sttp.tapir.server.netty.NettyFutureServer
\end_layout

\begin_layout Plain Layout

import scala.concurrent.ExecutionContext.Implicits.global
\end_layout

\begin_layout Plain Layout

import scala.concurrent.Await
\end_layout

\begin_layout Plain Layout

import scala.concurrent.duration.*
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

@main def startApi():
 Unit =
\end_layout

\begin_layout Plain Layout

  // 1.
 Combine your business logic endpoints into a list
\end_layout

\begin_layout Plain Layout

  val allEndpoints = List(helloLogic,
 statsLogic)
\end_layout

\begin_layout Plain Layout

  
\end_layout

\begin_layout Plain Layout

  // 2.
 Add the auto-generated Swagger docs to the mix
\end_layout

\begin_layout Plain Layout

  val routes = allEndpoints ++ swaggerEndpoints
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // 3.
 Start the Netty server on port 8080
\end_layout

\begin_layout Plain Layout

  val binding = NettyFutureServer()
\end_layout

\begin_layout Plain Layout

    .port(8080)
\end_layout

\begin_layout Plain Layout

    .addEndpoints(routes)
\end_layout

\begin_layout Plain Layout

    .start()
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  println("Renaissance Server started at http://localhost:8080")
\end_layout

\begin_layout Plain Layout

  println("Documentation available at http://localhost:8080/docs")
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

  // Keep the server running
\end_layout

\begin_layout Plain Layout

  Await.result(binding,
 Duration.Inf)
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
subsection*{Summary:
 The Web Stack}
\end_layout

\begin_layout Plain Layout

The Renaissance approach to the web favors 
\backslash
textbf{Types over Strings}.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout

    
\backslash
item 
\backslash
textbf{High Performance}:
 Powered by Netty's non-blocking I/O.
\end_layout

\begin_layout Plain Layout

    
\backslash
item 
\backslash
textbf{Type Safe}:
 If it compiles,
 your API shapes are guaranteed.
\end_layout

\begin_layout Plain Layout

    
\backslash
item 
\backslash
textbf{Interactive}:
 Swagger UI is generated for free.
\end_layout

\begin_layout Plain Layout

    
\backslash
item 
\backslash
textbf{Zero Boilerplate}:
 No XML,
 no complex config files.
\end_layout

\begin_layout Plain Layout


\backslash
end{itemize}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
section*{Chapter 16.6:
 Running from the Command Line}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

In the Renaissance ecosystem,
 we want the distance between "writing code" and "running a server" to be as short as possible.
 Because we are using 
\backslash
texttt{scala-cli},
 you don't need to install a complex build tool or configure an IDE to see your API in action.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
subsection*{The Project Configuration}
\end_layout

\begin_layout Plain Layout

To ensure all the parts we've discussed (Tapir,
 Netty,
 Doobie,
 and sttp) are available,
 we create a 
\backslash
texttt{project.scala} file in the same directory as our source code.
 This acts as our manifest.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

//> using scala "3.3.1"
\end_layout

\begin_layout Plain Layout

//> using dep "com.softwaremill.sttp.tapir::tapir-netty-server:1.9.0"
\end_layout

\begin_layout Plain Layout

//> using dep "com.softwaremill.sttp.tapir::tapir-json-zio:1.9.0"
\end_layout

\begin_layout Plain Layout

//> using dep "com.softwaremill.sttp.tapir::tapir-swagger-ui-bundle:1.9.0"
\end_layout

\begin_layout Plain Layout

//> using dep "com.softwaremill.sttp.client3::core:3.9.0"
\end_layout

\begin_layout Plain Layout

//> using dep "org.tpolecat::doobie-core:1.0.0-RC4"
\end_layout

\begin_layout Plain Layout

//> using dep "org.tpolecat::doobie-postgres:1.0.0-RC4"
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
subsection*{Starting the Server}
\end_layout

\begin_layout Plain Layout

Once your code and configuration are in place,
 you can launch the server with one command.
 Scala-cli will automatically download the libraries,
 compile the code,
 and execute the 
\backslash
texttt{@main} method.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

# Run the application
\end_layout

\begin_layout Plain Layout

scala-cli run .
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
subsection*{The Hot-Reload Workflow}
\end_layout

\begin_layout Plain Layout

For the best developer experience,
 use the 
\backslash
texttt{--watch} flag.
 This tells the compiler to stay active.
 Every time you save a change in your editor—
perhaps to add a new API field or change a database query—
the server will automatically re-compile and restart in less than a second.
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

# Run with automatic restarts on save
\end_layout

\begin_layout Plain Layout

scala-cli run .
 --watch
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout


\backslash
subsection*{Testing the Live API}
\end_layout

\begin_layout Plain Layout

Once the server reports it is "Started," you can interact with it immediately.
 You have three primary ways to verify it's working:
\end_layout

\begin_layout Plain Layout


\backslash
begin{enumerate}
\end_layout

\begin_layout Plain Layout

    
\backslash
item 
\backslash
textbf{The Browser}:
 Visit 
\backslash
texttt{http://localhost:8080/docs} to see the interactive Swagger UI.
\end_layout

\begin_layout Plain Layout

    
\backslash
item 
\backslash
textbf{The Terminal}:
 Use 
\backslash
texttt{curl "http://localhost:8080/hello?name=Pragmatist"} to see a raw response.
\end_layout

\begin_layout Plain Layout

    
\backslash
item 
\backslash
textbf{The REPL}:
 Run 
\backslash
texttt{scala-cli repl .} and use 
\backslash
texttt{sttp} to call your own server programmatically.
\end_layout

\begin_layout Plain Layout


\backslash
end{enumerate}
\end_layout

\begin_layout Plain Layout

---
\end_layout

\begin_layout Plain Layout


\backslash
textit{Reviewer’s Notes:
 This stack represents the "Holy Trinity" of modern Scala web development.
 It’s safe,
 fast,
 and self-documenting.}
\end_layout

\end_inset


\end_layout

\end_body
\end_document
