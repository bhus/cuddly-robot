#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\use_default_options true
\maintain_unincluded_children no
\language american
\language_package default
\inputencoding utf8
\fontencoding auto
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement class
\float_alignment class
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_formatted_ref 0
\use_minted 0
\use_lineno 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tablestyle default
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content true
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Standard
In a perfect world,
 databases never time out and users never type "potato" into an age field.
 In the real world,
 things go wrong.
 Scala assumes you know this,
 and it gives you a tiered defense system to handle the chaos.
\end_layout

\begin_layout Subsection*
The Traditional Guard:
 Try/Catch
\end_layout

\begin_layout Standard
If you’ve used Java or C#,
 the try/catch block will feel like a warm,
 familiar blanket.
 However,
 Scala gives it a "matching" upgrade.
 Instead of separate catch blocks for every type,
 you use a single match-style block to sort through the wreckage.
\end_layout

\begin_layout LyX-Code
try {
\end_layout

\begin_layout LyX-Code
  // A risky Doobie database call
\end_layout

\begin_layout LyX-Code
} catch {
\end_layout

\begin_layout LyX-Code
  case ex:
 java.sql.SQLException if ex.getErrorCode == 101 => 
\end_layout

\begin_layout LyX-Code
    println("Specific DB Error:
 Check your permissions.")
\end_layout

\begin_layout LyX-Code
  case ex:
 Exception => 
\end_layout

\begin_layout LyX-Code
    println(s"Generic Error:
 ${ex.getMessage}")
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Subsubsection*
Raising Exceptions
\end_layout

\begin_layout Standard
You can throw exceptions exactly as you’d expect.
 In fact,
 using Case Classes to define custom errors makes them incredibly easy to read and create.
\end_layout

\begin_layout LyX-Code
case class DatabaseException(msg:
 String,
 code:
 Int) extends Exception(msg)
\end_layout

\begin_layout LyX-Code
def getUser(id:
 Int):
 String =
\end_layout

\begin_layout LyX-Code
  if id < 0 then throw DatabaseException("Invalid ID",
 400)
\end_layout

\begin_layout LyX-Code
  else "Alice"
\end_layout

\begin_layout Subsection*
The Functional Guard:
 The Try Container
\end_layout

\begin_layout Standard
While try/catch works,
 it has a downside:
 it "interrupts" the flow of your program.
 In modern Scala,
 we prefer the Try container.
 Instead of a crash,
 it returns a "box" that contains either a Success or a Failure.
\end_layout

\begin_layout LyX-Code
import scala.util.{Try,
 Success,
 Failure}
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
val result:
 Try[Int] = Try("123".toInt)
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
result match
\end_layout

\begin_layout LyX-Code
  case Success(num) => println(s"Value is:
 $num")
\end_layout

\begin_layout LyX-Code
  case Failure(ex) => println(s"Conversion failed:
 ${ex.getMessage}")
\end_layout

\begin_layout Standard
This is the "Pragmatic" way.
 By returning a Try,
 you tell the next developer:
 "This might fail,
 and the compiler is going to make sure you deal with that possibility."
\end_layout

\begin_layout Subsection*
Either:
 Choosing a Side
\end_layout

\begin_layout Standard
The Either container is the preferred way to handle business logic errors.
 By convention,
 the 
\series bold
Left
\series default
 side holds the error (because "left" is also a synonym for "sinister" or "wrong" in Latin roots) and the 
\series bold
Right
\series default
 side holds the "right" (correct) result.
\end_layout

\begin_layout LyX-Code
def divide(a:
 Int,
 b:
 Int):
 Either[String,
 Int] =
\end_layout

\begin_layout LyX-Code
  if b == 0 then Left("Cannot divide by zero!")
\end_layout

\begin_layout LyX-Code
  else Right(a / b)
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
val outcome = divide(10,
 0) // Result:
 Left("Cannot divide by zero!")
\end_layout

\begin_layout Subsection*
System Hygiene:
 NonFatal and Finally
\end_layout

\begin_layout Standard
Not all errors are created equal.
 If your program runs out of memory (OutOfMemoryError),
 there is usually nothing you can do—
the app is going to crash.
 Scala provides the NonFatal helper to help you catch the "recoverable" stuff while letting the catastrophic stuff through.
\end_layout

\begin_layout LyX-Code
import scala.util.control.NonFatal
\end_layout

\begin_layout LyX-Code
try {
\end_layout

\begin_layout LyX-Code
  // Risky System Access
\end_layout

\begin_layout LyX-Code
} catch {
\end_layout

\begin_layout LyX-Code
  case NonFatal(ex) => println(s"Recoverable error:
 $ex")
\end_layout

\begin_layout LyX-Code
  // OutOfMemoryError will bypass this and crash the app safely
\end_layout

\begin_layout LyX-Code
}
\end_layout

\begin_layout Subsubsection*
The finally Guarantee
\end_layout

\begin_layout Standard
When you open a file or a database connection,
 you must close it,
 regardless of what happens in between.
 The finally block is your iron-clad guarantee.
\end_layout

\begin_layout LyX-Code
val source = scala.io.Source.fromFile("renaissance.txt")
\end_layout

\begin_layout LyX-Code
try 
\end_layout

\begin_layout LyX-Code
  println(source.mkString)
\end_layout

\begin_layout LyX-Code
finally 
\end_layout

\begin_layout LyX-Code
  source.close() // This runs NO MATTER WHAT
\end_layout

\begin_layout LyX-Code
  println("Resource safely closed.")
\end_layout

\end_body
\end_document
