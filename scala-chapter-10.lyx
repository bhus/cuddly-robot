#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\use_default_options true
\maintain_unincluded_children no
\language american
\language_package default
\inputencoding utf8
\fontencoding auto
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement class
\float_alignment class
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_formatted_ref 0
\use_minted 0
\use_lineno 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tablestyle default
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content true
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Standard
At some point,
 your beautiful Scala logic needs to interact with the cold,
 hard reality of the file system.
 Because Scala runs on the JVM,
 you have access to the ultra-reliable Java NIO (New I/O) libraries,
 but Scala provides some "syntactic sugar" to make these interactions feel much more natural.
\end_layout

\begin_layout Subsection*
Reading Files:
 The Safe Way
\end_layout

\begin_layout Standard
The most common mistake in I/O is opening a file and forgetting to close it.
 In Scala,
 we use the .using pattern (or manual resource management) to ensure that once we are done reading,
 the file handle is snapped shut immediately.
\end_layout

\begin_layout LyX-Code
import scala.io.Source
\end_layout

\begin_layout LyX-Code
import scala.util.Using
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
// 'Using' is a manager:
 it opens the resource and closes it 
\end_layout

\begin_layout LyX-Code
// automatically even if your code crashes in the middle.
\end_layout

\begin_layout LyX-Code
val lines:
 Try[List[String]] = Using(Source.fromFile("config.txt")) { source =>
\end_layout

\begin_layout LyX-Code
  source.getLines().toList
\end_layout

\begin_layout LyX-Code
}
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
lines match
\end_layout

\begin_layout LyX-Code
  case Success(content) => println(s"Read ${content.size} lines.")
\end_layout

\begin_layout LyX-Code
  case Failure(e) => println(s"Failed to read file:
 ${e.getMessage}")
\end_layout

\begin_layout Standard
By wrapping our file access in Using,
 we convert a risky operation into a Try container (which we learned about in Chapter 8).
 It's safe,
 predictable,
 and clean.
\end_layout

\begin_layout Subsection*
Writing Files:
 Leveraging the JVM
\end_layout

\begin_layout Standard
For writing data,
 we often lean on the robust java.nio libraries.
 While they look a bit more "Java-ish," they are incredibly fast and handle character encoding (like UTF-8) with precision.
\end_layout

\begin_layout LyX-Code
import java.nio.file.{Files,
 Paths}
\end_layout

\begin_layout LyX-Code
import java.nio.charset.StandardCharsets
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
val path = Paths.get("output.txt")
\end_layout

\begin_layout LyX-Code
val data = "Hello,
 Renaissance!
\backslash
nThis is Scala 3."
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
// Files.write is a 'one-shot' operation:
 it opens,
 writes,
 and closes.
\end_layout

\begin_layout LyX-Code
Files.write(path,
 data.getBytes(StandardCharsets.UTF_8))
\end_layout

\begin_layout Subsection*
The Modern Approach:
 "Source" Shortcuts
\end_layout

\begin_layout Standard
If you just need to grab the entire contents of a file as a single string (common for config files or templates),
 Scala makes it a one-liner:
\end_layout

\begin_layout LyX-Code
val content = Source.fromFile("banner.txt").mkString
\end_layout

\begin_layout Standard

\series bold
A Note on Performance
\series default
:
 Source.fromFile is great for simple tasks,
 but if you are processing a 10GB log file,
 you'll want to use source.getLines() which is lazy.
 It doesn't load the whole file into RAM;
 it just gives you one line at a time as you ask for it.
\end_layout

\begin_layout Subsection*
Working with Paths
\end_layout

\begin_layout Standard
Instead of treating file locations as messy strings like "C:/users/docs/file.txt",
 we use the Paths and Path objects.
 This makes your code "cross-platform," meaning it will work on Windows,
 macOS,
 and Linux without you having to worry about backslashes versus forward slashes.
\end_layout

\begin_layout LyX-Code
val dir = Paths.get("data",
 "logs")
\end_layout

\begin_layout LyX-Code
val file = dir.resolve("app.log") // Automatically handles separators
\begin_inset Newline newline
\end_inset


\end_layout

\begin_layout LyX-Code
println(s"Looking for file at:
 ${file.toAbsolutePath}")
\end_layout

\end_body
\end_document
