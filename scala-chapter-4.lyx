#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\use_default_options true
\maintain_unincluded_children no
\language american
\language_package default
\inputencoding utf8
\fontencoding auto
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement class
\float_alignment class
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_formatted_ref 0
\use_minted 0
\use_lineno 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tablestyle default
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content true
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Standard
Scala owns performance and in particular big data.
 So it makes sense that collections would be where it outshines most other languages.
 
\end_layout

\begin_layout Standard
There are 3 basic,
 big-name collections:
 lists,
 vectors,
 and maps.
 
\end_layout

\begin_layout Subsection*

\family sans
Lists
\end_layout

\begin_layout Standard
Lists hold collections of objects (object references if you want to be specific),
 with each object occupying a position in the array at a given *index* (eg.
 0,
 1,
 2...n).
 They are the break and butter for small to medium sized data sets.
\end_layout

\begin_layout Standard
Lists by default are *immutable*,
 meaning they can't be added to.
 The pattern if we need to update a list is to create a new one that is a copy of the existing + given new elements.
\end_layout

\begin_layout LyX-Code
val fruit = List("Apple",
 "Banana",
 "Cherry")
\end_layout

\begin_layout LyX-Code
var pickOne = fruit(0) // Returns 
\begin_inset Quotes eld
\end_inset

Apple
\begin_inset Quotes erd
\end_inset


\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

val moreFruit = 
\begin_inset Quotes eld
\end_inset

Dragonfruit
\begin_inset Quotes erd
\end_inset

 ::
 fruit
\end_layout

\begin_layout LyX-Code
val changeCherry = fruit.updated(2,
 
\begin_inset Quotes eld
\end_inset

Kiwi
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard
Note the use of 
\begin_inset Quotes eld
\end_inset

()
\begin_inset Quotes erd
\end_inset

 syntax to get element,
 rather than 
\begin_inset Quotes eld
\end_inset

[]
\begin_inset Quotes erd
\end_inset

 in other languages.
 This is one of the beauties of scala but also why some folks coming from other languages label it as 
\begin_inset Quotes eld
\end_inset

hard
\begin_inset Quotes erd
\end_inset

:
 it is not afraid to break conventions of other languages (*cough* C *cough*).
\end_layout

\begin_layout Standard
Also,
 we add an element by creating a new list with the changes:
 we can create a new list with the new value added (in this case we prepend),
 the new value substituted into a given index,
 or an old value dropped.
\end_layout

\begin_layout LyX-Code
val noFirstFruit = fruit.drop(1) // drops everything to the left of the given index
\end_layout

\begin_layout LyX-Code
val noLastFruit = fruit.dropRight(1) // drops everything to the right of the given index
\end_layout

\begin_layout LyX-Code
val dropBananaAddCitruses =  fruit.patch(1,
 List(
\begin_inset Quotes eld
\end_inset

lemon
\begin_inset Quotes erd
\end_inset

,
 
\begin_inset Quotes eld
\end_inset

lime
\begin_inset Quotes erd
\end_inset

),
 1) // remove banana,
 add more citrus in the middle
\end_layout

\begin_layout Standard
Note:
 obj.patch(fromIndex,
 replacementCollection,
 numberOfElementsToRemove) combines a few of these into one,
 where we give it an index & number of elements to remove,
 as well as an optional new list to insert.
\end_layout

\begin_layout Standard
This approach encourages mapping operations & comprehensive changes (which we will discuss in a minute) over one-offs.
\end_layout

\begin_layout Subsection*

\family sans
Maps (Hashes)
\end_layout

\begin_layout Standard
Hashes are collections where the elements are indexed by a key that can be any type of object or values (not necessarily integers in order):
\end_layout

\begin_layout LyX-Code
val meal = Map(
\begin_inset Quotes eld
\end_inset

main course
\begin_inset Quotes erd
\end_inset

 -> "lobster",
 
\begin_inset Quotes eld
\end_inset

appetizer
\begin_inset Quotes erd
\end_inset

 -> "escargots",
 
\begin_inset Quotes eld
\end_inset

dessert
\begin_inset Quotes erd
\end_inset

 -> 
\begin_inset Quotes eld
\end_inset

chocolate cake
\begin_inset Quotes erd
\end_inset

)
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

val appies = meal(
\begin_inset Quotes eld
\end_inset

appetizer
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Standard
Notice that there's no sequencing requirement.
 The only constraint is that keys must be of the same type.
\end_layout

\begin_layout Subsection*

\family sans
Vectors
\end_layout

\begin_layout Standard
Vectors list lists,
 but are optimized for *random-access*,
 as opposed to iteration.
 That is to say,
 even if your collection is enormous,
 if you need the middle element you can jump there immediately.
\end_layout

\begin_layout LyX-Code
val trees = Vector(
\begin_inset Quotes eld
\end_inset

pine
\begin_inset Quotes erd
\end_inset

,
 
\begin_inset Quotes eld
\end_inset

birch
\begin_inset Quotes erd
\end_inset

,
 
\begin_inset Quotes eld
\end_inset

maple
\begin_inset Quotes erd
\end_inset

)
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

val whitey = trees(trees.length / 2) // Grab middle element
\end_layout

\begin_layout Standard
This may seem unimpressive,
 but as data sets grow large,
 the last statement will typically perform better with a vector than a list.
\end_layout

\begin_layout Subsection*

\family sans
Blocks (aka 
\begin_inset Quotes eld
\end_inset

Higher Order Functions
\begin_inset Quotes erd
\end_inset

) & Iterators
\end_layout

\begin_layout Standard
Now,
 imagine that we have a list of company objects (see above).
 Let's create a company list class for some common operations on company lists:
\end_layout

\begin_layout LyX-Code
class CompanyList(companies:
 List[Company])
\end_layout

\begin_layout LyX-Code
  def withBrand(brand:String):Option[Company] =
\end_layout

\begin_layout LyX-Code
    companies.find { c =>
\begin_inset Newline newline
\end_inset

      c.name == brand
\begin_inset Newline newline
\end_inset

    }
\begin_inset Newline newline
\end_inset


\begin_inset Newline newline
\end_inset

// Use it!
\begin_inset Newline newline
\end_inset

val c = CompanyList( List(Company("Nike",
 10),
 Company("Reebok",
 20)) )
\begin_inset Newline newline
\end_inset

c.withBrand { "Reebok" }
\end_layout

\begin_layout Standard
Note that in withBrand we are take a brand name,
 and then execute the 
\begin_inset Quotes eld
\end_inset

find
\begin_inset Quotes erd
\end_inset

 method with a strange iterator 
\emph on
code block
\emph default
 attached:
\end_layout

\begin_layout Standard
- the 
\begin_inset Quotes eld
\end_inset

 c => 
\begin_inset Quotes eld
\end_inset

 syntax says 
\begin_inset Quotes eld
\end_inset

for each element in the collection,
 assign it to the variable defined left of the 
\begin_inset Quotes eld
\end_inset

=>
\begin_inset Quotes erd
\end_inset

 (in this case 'c'),
 
\end_layout

\begin_layout Standard
- then run the chunk of code after the 
\begin_inset Quotes eld
\end_inset

=>
\begin_inset Quotes erd
\end_inset

 for each element in the collection
\end_layout

\begin_layout Standard
What happens with the result of this block depends on the method it's used for.
 In this case,
 it's expected to return a boolean value,
 and will return the first element where the code block returns true.
 [ Well that's not quite true actually â€“ it will return a value of Some[
\emph on
value
\emph default
] ( or None if no elements are found ) ]
\end_layout

\begin_layout Standard
NOTE:
 another quick thing to notice here is that there is no 
\begin_inset Quotes eld
\end_inset

return
\begin_inset Quotes erd
\end_inset

 statement here.
 That's basically a convenience measure for clarity,
 where the method takes the last statement of it's call chain and assumes that is what it should return.
\end_layout

\begin_layout Standard
We could also generalize this statement and allow *any* code block to be taken to evaluate against the list to find an element:
\end_layout

\begin_layout LyX-Code
  def findFlex(block:
 Company => Boolean):Option[Company] =
\end_layout

\begin_layout LyX-Code
    companies.find { c => 
\begin_inset Newline newline
\end_inset

      block(c)
\begin_inset Newline newline
\end_inset

    }
\end_layout

\begin_layout Standard
Notice how the parameter is defined here:
 
\end_layout

\begin_layout LyX-Code
block:
 Company => Boolean
\end_layout

\begin_layout Standard
This tells the method the parameter is named block,
 and it expects a code block that will take a Company as a parameter and return a boolean result.
\end_layout

\begin_layout Standard
We can then invoke it with:
\end_layout

\begin_layout LyX-Code
c.findFlex { c => c.name == "Reebok" }
\end_layout

\begin_layout Standard
NOTE:
 Many language stop here,
 but scala actually refines this further with a convenient shorthand syntax,
 where we can use underscore ( 
\begin_inset Quotes eld
\end_inset

_
\begin_inset Quotes erd
\end_inset

 ) to mean the current element in our iteration.
 So the above would become:
\end_layout

\begin_layout LyX-Code
c.findFlex { _.name == "Reebok" }
\end_layout

\end_body
\end_document
