#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\use_default_options true
\maintain_unincluded_children no
\language american
\language_package default
\inputencoding utf8
\fontencoding auto
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement class
\float_alignment class
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_formatted_ref 0
\use_minted 0
\use_lineno 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tablestyle default
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content true
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Standard
Scala is the undisputed heavyweight champion of big data.
 It makes sense,
 then,
 that its collections are where the language outshines almost everything else.
 While other languages treat lists as simple storage,
 Scala treats them as high-speed engines for transformation.
\end_layout

\begin_layout Subsection*
The Big Three:
 Lists,
 Vectors,
 and Maps
\end_layout

\begin_layout Standard
In Scala,
 we typically reach for three primary containers.
 By default,
 these are immutable.
 You don't "change" a list;
 you create a new,
 refined version of it.
\end_layout

\begin_layout Subsubsection*
Lists:
 The Bread and Butter
\end_layout

\begin_layout Standard
A List is an ordered sequence,
 ideal for small to medium-sized data.
 Scala uses () for indexing rather than [],
 a small departure from C-style languages that hints at Scala's mathematical roots.
\end_layout

\begin_layout LyX-Code
val fruit = List("Apple",
 "Banana",
 "Cherry")
\end_layout

\begin_layout LyX-Code
val first = fruit(0) // "Apple"
\end_layout

\begin_layout LyX-Code
// Prepending (Adding to the front)
\end_layout

\begin_layout LyX-Code
val moreFruit = "Dragonfruit" ::
 fruit 
\end_layout

\begin_layout LyX-Code
// Updating (Creating a new list with one change)
\end_layout

\begin_layout LyX-Code
val kiwiList = fruit.updated(2,
 "Kiwi") 
\end_layout

\begin_layout Standard
Scala provides powerful tools like .patch to perform surgery on your data:
\end_layout

\begin_layout LyX-Code
Scala
\end_layout

\begin_layout LyX-Code
// Remove 1 element at index 1,
 and insert "Lemon" and "Lime"
\end_layout

\begin_layout LyX-Code
val citruses = fruit.patch(1,
 List("Lemon",
 "Lime"),
 1)
\end_layout

\begin_layout Subsubsection*
Vectors:
 The Random-Access Specialist
\end_layout

\begin_layout Standard
If your dataset is enormous and you need to jump to the middle of it instantly,
 use a Vector.
 While a List has to walk from the beginning to find the 10,000th element,
 a Vector can "teleport" there.
\end_layout

\begin_layout LyX-Code
Scala
\end_layout

\begin_layout LyX-Code
val trees = Vector("Pine",
 "Birch",
 "Maple")
\end_layout

\begin_layout LyX-Code
val middle = trees(trees.length / 2)
\end_layout

\begin_layout Subsubsection*
Maps:
 The Dictionary
\end_layout

\begin_layout Standard
A Map (often called a Hash or Dictionary) stores pairs of keys and values.
 There is no sequencing requirement here;
 you just need to know the key.
\end_layout

\begin_layout LyX-Code
Scala
\end_layout

\begin_layout LyX-Code
val meal = Map(
\end_layout

\begin_layout LyX-Code
  "main" -> "Lobster",
 
\end_layout

\begin_layout LyX-Code
  "starter" -> "Escargots"
\end_layout

\begin_layout LyX-Code
)
\end_layout

\begin_layout LyX-Code
val appy = meal("starter") // "Escargots"
\end_layout

\begin_layout Subsection*
The Iterator Block (Higher-Order Functions)
\end_layout

\begin_layout Standard
This is where Scala gets exciting.
 Instead of writing manual for loops with counters and temporary variables,
 we use Blocks.
\end_layout

\begin_layout Standard
Imagine we have a list of Company objects.
 We want to find a specific one.
\end_layout

\begin_layout LyX-Code
Scala
\end_layout

\begin_layout LyX-Code
class CompanyList(companies:
 List[Company]):
\end_layout

\begin_layout LyX-Code
  def withBrand(brand:
 String):
 Option[Company] =
\end_layout

\begin_layout LyX-Code
    companies.find { c => 
\end_layout

\begin_layout LyX-Code
      c.name == brand 
\end_layout

\begin_layout LyX-Code
    }
\end_layout

\begin_layout Standard

\series bold
Let’s break down that { c => ...
 } syntax:
\end_layout

\begin_layout Enumerate

\series bold
The Variable (c):

\series default
 This is a temporary name for "the current element" as Scala walks through the list.
\end_layout

\begin_layout Enumerate

\series bold
The Arrow (=>):

\series default
 This separates the variable name from the logic.
\end_layout

\begin_layout Enumerate

\series bold
The Result:

\series default
 The find method expects a Boolean.
 It will return the first element where your block results in true.
\begin_inset Newline newline
\end_inset


\series bold
Note on Returns:

\series default
 You won't see a return keyword here.
 In Scala,
 the last expression in a block is automatically the return value.
 It’s cleaner,
 less noisy,
 and perfectly "Pragmatic."
\end_layout

\begin_layout Subsection*
Flexible Logic:
 Passing Blocks
\end_layout

\begin_layout Standard
We can take this a step further.
 What if we want to allow the user of our class to decide how to find a company?
 We can define a method that accepts a code block as a parameter.
\end_layout

\begin_layout LyX-Code
def findFlex(check:
 Company => Boolean):
 Option[Company] =
\end_layout

\begin_layout LyX-Code
  companies.find { c => check(c) }
\end_layout

\begin_layout Standard
The type Company => Boolean tells the compiler:
 "This method expects a function that takes a Company and returns true or false."
\end_layout

\begin_layout Standard
Now,
 we can call it with whatever logic we want:
\end_layout

\begin_layout LyX-Code
// Long form
\end_layout

\begin_layout LyX-Code
myList.findFlex { c => c.name == "Reebok" }
\end_layout

\begin_layout LyX-Code
// The Professional Shorthand
\end_layout

\begin_layout LyX-Code
myList.findFlex { _.name == "Reebok" }
\end_layout

\begin_layout Standard

\series bold
The Underscore (_):

\series default
 This is the ultimate Scala shorthand.
 It means "the current item." If you only use the variable once in your block,
 you can toss the c => and just use the underscore.
 It turns your code into a succinct,
 readable sentence.
\end_layout

\end_body
\end_document
