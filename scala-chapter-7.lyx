#LyX 2.4 created this file. For more info see https://www.lyx.org/
\lyxformat 620
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass book
\use_default_options true
\maintain_unincluded_children no
\language american
\language_package default
\inputencoding utf8
\fontencoding auto
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_roman_osf false
\font_sans_osf false
\font_typewriter_osf false
\font_sf_scale 100 100
\font_tt_scale 100 100
\use_microtype false
\use_dash_ligatures true
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement class
\float_alignment class
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\use_formatted_ref 0
\use_minted 0
\use_lineno 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\is_math_indent 0
\math_numbering_side default
\quotes_style english
\dynamic_quotes 0
\papercolumns 1
\papersides 1
\paperpagestyle default
\tablestyle default
\tracking_changes false
\output_changes false
\change_bars false
\postpone_fragile_content true
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\docbook_table_output 0
\docbook_mathml_prefix 1
\end_header

\begin_body

\begin_layout Standard
In many languages,
 control flow is a series of gates and loops—
if this,
 then that;
 while this,
 do that.
 Scala offers those,
 but it prefers something more elegant.
 It treats your code like a 
\series bold
transformation
\series default
 rather than a set of instructions.
\end_layout

\begin_layout Subsection*
Custom Operators:
 Making Code Readable
\end_layout

\begin_layout Standard
Scala allows you to redefine operators like +,
 -,
 or *.
 While this sounds like a "scripting" trick,
 it’s actually a way to make your domain logic read like a native part of the language.
\end_layout

\begin_layout LyX-Code
Scala
\end_layout

\begin_layout LyX-Code
case class Position(x:
 Int,
 y:
 Int):
\end_layout

\begin_layout LyX-Code
def +(other:
 Position):
 Position =
\end_layout

\begin_layout LyX-Code
Position(this.x + other.x,
 this.y + other.y)
\end_layout

\begin_layout LyX-Code
val p1 = Position(10,
 20)
\end_layout

\begin_layout LyX-Code
val p2 = Position(5,
 5)
\end_layout

\begin_layout LyX-Code
val p3 = p1 + p2 // Result:
 Position(15,
 25)
\end_layout

\begin_layout Subsection*
Conditionals and the "Safe" Choice
\end_layout

\begin_layout Standard
Since Scala shuns null,
 we don't use the standard "if-not-null" checks.
 Instead,
 we use "coalescing" to provide defaults.
\end_layout

\begin_layout LyX-Code
Scala
\end_layout

\begin_layout LyX-Code
val storedName:
 Option[String] = None
\end_layout

\begin_layout LyX-Code
val name = storedName.getOrElse("Guest") // The "Elvis" move
\end_layout

\begin_layout Subsubsection*
If-Guards
\end_layout

\begin_layout Standard
An
\series bold
 If-Guard
\series default
 is a filter applied directly to a control structure.
 Instead of wrapping your logic in a giant if block inside a loop,
 you simply "guard" the entrance:
\end_layout

\begin_layout LyX-Code
Scala
\end_layout

\begin_layout LyX-Code
val numbers = List(1,
 2,
 3,
 10,
 20)
\end_layout

\begin_layout LyX-Code
for 
\end_layout

\begin_layout LyX-Code
n <- numbers 
\end_layout

\begin_layout LyX-Code
if n > 5 // This is the guard
\end_layout

\begin_layout LyX-Code
do 
\end_layout

\begin_layout LyX-Code
println(s"Large number:
 $n")
\end_layout

\begin_layout Subsection*
Pattern Matching:
 The Table of Contents
\end_layout

\begin_layout Standard
Pattern matching is the defining feature of Scala.
 It’s not just a "switch" statement;
 it’s a way to deconstruct your data and act on its shape.
\end_layout

\begin_layout LyX-Code
Scala
\end_layout

\begin_layout LyX-Code
val toTest:
 Any = "Success"
\end_layout

\begin_layout LyX-Code
toTest match
\end_layout

\begin_layout LyX-Code
case 0 => "It's a zero" // Constant match
\end_layout

\begin_layout LyX-Code
case "Success" => "It's a win!" // Value match
\end_layout

\begin_layout LyX-Code
case s:
 String => s"It's a string of length ${s.length}" // Type match
\end_layout

\begin_layout LyX-Code
case _ => "Fallback" // The Wildcard
\end_layout

\begin_layout Subsubsection*
Destructuring:
 Looking Inside
\end_layout

\begin_layout Standard
The real magic happens when you use matching to "reach inside" an object.
 This is called 
\series bold
destructuring
\series default
.
\end_layout

\begin_layout LyX-Code
Scala
\end_layout

\begin_layout LyX-Code
case class User(name:
 String,
 role:
 String)
\end_layout

\begin_layout LyX-Code
val user = User("Alice",
 "Admin")
\end_layout

\begin_layout LyX-Code
user match
\end_layout

\begin_layout LyX-Code
case User("Alice",
 _) => "Hi Alice!" // Ignore the role
\end_layout

\begin_layout LyX-Code
case User(name,
 "Admin") => s"Alert:
 Admin $name is here."
\end_layout

\begin_layout LyX-Code
case User(name,
 role) => s"User $name is a $role"
\end_layout

\begin_layout Standard
You can even match on the 
\series bold
shape of a List
\series default
:
\end_layout

\begin_layout LyX-Code
Scala
\end_layout

\begin_layout LyX-Code
val list = List(1,
 2,
 3)
\end_layout

\begin_layout LyX-Code
list match
\end_layout

\begin_layout LyX-Code
case Nil => "Empty"
\end_layout

\begin_layout LyX-Code
case List(x) => s"Just one item:
 $x"
\end_layout

\begin_layout LyX-Code
case head ::
 tail => s"Starts with $head,
 followed by $tail"
\end_layout

\begin_layout Subsection*
The Loop Evolution
\end_layout

\begin_layout Standard
In procedural programming,
 we use loops to do things.
 In Scala,
 we use them to evolve data.
\end_layout

\begin_layout Subsubsection*
The Side-Effect Loop
\end_layout

\begin_layout Standard
We use do when we want to interact with the outside world (I/O,
 printing,
 databases).
 This is where the loop has a "side effect."
\end_layout

\begin_layout LyX-Code
Scala
\end_layout

\begin_layout LyX-Code
val apps = List("sttp",
 "Doobie",
 "Tapir")
\end_layout

\begin_layout LyX-Code
for app <- apps do
\end_layout

\begin_layout LyX-Code
println(s"Learning $app...")
\end_layout

\begin_layout Subsubsection*
The Functional Loop (Comprehensions)
\end_layout

\begin_layout Standard
When we want to create a new list from an old one,
 we use yield.
 This is the "Functional Loop."
\end_layout

\begin_layout LyX-Code
Scala
\end_layout

\begin_layout LyX-Code
val names = List("alice",
 "bob",
 "charlie")
\end_layout

\begin_layout LyX-Code
val capitalizedAdmins = for
\end_layout

\begin_layout LyX-Code
name <- names
\end_layout

\begin_layout LyX-Code
if name.startsWith("a") // The Guard:
 Filters the input
\end_layout

\begin_layout LyX-Code
yield
\end_layout

\begin_layout LyX-Code
name.capitalize // The Yield:
 Transforms the result
\end_layout

\begin_layout LyX-Code
// Result:
 List("Alice")
\end_layout

\begin_layout Subsection*
Why the "Mind Shift" Matters
\end_layout

\begin_layout Standard
It may help to think of Scala as a language designed with mathematical symmetry.
 In a traditional loop,
 you are managing the state of the computer.
 In a Scala comprehension or match statement,
 you are describing the relationship between your input and your output.
\end_layout

\begin_layout Standard
It’s less about "doing" and more about "becoming."
\end_layout

\end_body
\end_document
